from code_generators.common.helper_functions import num_arr_to_cppArrStr
from code_generators.common.helper_functions import binary_arr_to_cppArrStr

def gen_genTF_function():
    line = ""
    line += "/* Generate twiddle factors for radix 2 NTT. " + "\n"
    line += "In normal radix-2 case, twiddle factors are used in increasing power order" + "\n"
    line += "*/" + "\n"
    line += "void generateTFForRadix2NTT(WORD root, WORD size, WORD mod, std::vector<WORD>& TFArr){" + "\n"
    line += "  WORD tempTF = 1;" + "\n"
    line += "  for(int i=0; i<(size/2); i++){" + "\n"
    line += "    TFArr[i] = tempTF;" + "\n"
    line += "    tempTF = (WORD)((((DWORD)tempTF) * ((DWORD)root)) % ((DWORD)mod));" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Generate TFs for num_of_limbs when poly size is 'size' */" + "\n"
    line += "void generateTFsForMultipleLimbs(VAR_TYPE_32 num_of_limbs, VAR_TYPE_32 size, std::vector<WORD>& workingModulus_arr, std::vector<WORD>& root_arr, std::vector<WORD> (&tfArr)[PARA_LIMBS]){" + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<num_of_limbs; paraLimbCounter++){" + "\n"
    line += "    WORD root = root_arr[paraLimbCounter];" + "\n"
    line += "    WORD workingModulus = workingModulus_arr[paraLimbCounter];" + "\n"
    line += "    " + "\n"
    line += "    tfArr[paraLimbCounter].resize(size/2);" + "\n"
    line += "" + "\n"
    line += "    generateTFForRadix2NTT(root, size, workingModulus, tfArr[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    
    return line

def gen_fwd_TF_data_rearrange():

    line = ""

    line += "//This function is used to reorganize TFs for FWD transform in following conditions." + "\n"
    line += "//1. Only required TFs are stored" + "\n"
    line += "//2. One TF storage for 2 BUs with a distance of NUM_BU/2" + "\n"
    line += "//3. Chain broadcasting is used to load TFs." + "\n"
    line += "//4. Chain is for consecutive BUF modules." + "\n"
    line += "void fwd_organizeTFData(std::vector<WORD>& inpTfArr, std::vector<TF_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<TF_WIDE_DATA_PER_PARA_LIMB>> (&outTFArr)[TF_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  std::vector<VAR_TYPE_32> TFGroupsPerBuf;" + "\n"
    line += "  std::vector<WORD> TFValsPerBuf[NUM_BU/2];" + "\n"
    line += "  std::vector<WORD> TFValsPerPort[TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT];" + "\n"
    line += "" + "\n"
    line += "  int beta = (N)/(2*NUM_BU);" + "\n"
    line += "  " + "\n"
    line += "  for (VAR_TYPE_32 bufIdx=0; bufIdx<NUM_BU/2; bufIdx++){ //loop through the TF buffers(1 Buf for 2 BUs)" + "\n"
    line += "    TFGroupsPerBuf.clear();" + "\n"
    line += "    //calculate TF group indexes" + "\n"
    line += "    for(VAR_TYPE_32 i=0; i<2; i++){ //loop through 2 BUs" + "\n"
    line += "      VAR_TYPE_32 BUIdx = bufIdx+(i*(NUM_BU/2)); //recreate target BU index" + "\n"
    line += "      for(VAR_TYPE_32 stage=0; stage<=logBU; stage++){  //loop through bit size to extract different numbers created based on the BU index" + "\n"
    line += "        VAR_TYPE_32 tfGrpIdx = ((BUIdx) & ((1<<(stage)) - 1));" + "\n"
    line += "        TFGroupsPerBuf.push_back(tfGrpIdx);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "    //Sort and remove duplicate TF group indexes" + "\n"
    line += "    sort( TFGroupsPerBuf.begin(), TFGroupsPerBuf.end() );" + "\n"
    line += "    TFGroupsPerBuf.erase( unique( TFGroupsPerBuf.begin(), TFGroupsPerBuf.end() ), TFGroupsPerBuf.end() );" + "\n"
    line += "" + "\n"
    line += "    //adding TFs to respective Buf array based on the TF group index calculated before" + "\n"
    line += "    for(int numSets=0; numSets<TFGroupsPerBuf.size(); numSets++){" + "\n"
    line += "      int groupIndex = TFGroupsPerBuf[numSets];" + "\n"
    line += "      int TF_start_idx = groupIndex*beta;" + "\n"
    line += "      for(int idx=0; idx<beta; idx++){" + "\n"
    line += "        int tfIdx = TF_start_idx + idx;" + "\n"
    line += "        WORD tfVal = inpTfArr[tfIdx];" + "\n"
    line += "        TFValsPerBuf[bufIdx].push_back(tfVal);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  //combining data for different DDR ports fascilitating chain broadcasting as well." + "\n"
    line += "  for(int k=0; k<TF_PORTS_PER_PARA_LIMB; k++){    // Number of HBM ports for TF. We use TF_PORTS_PER_PARA_LIMB as we support more buffers per port for TFs compared to polynomials." + "\n"
    line += "" + "\n"
    line += "    //putting all data that goes to this paerticular port into one vector array. They are inserted according to the chain broadcasting pattern" + "\n"
    line += "    for(int s=0; s<NUM_CHAIN_GROUPS_PER_PARA_LIMB_TF_PORT; s++){ // How many 'Bufs groups' being supported by a HBM prot. A single 'Buf group' is 8 Bufs(HBM port width)." + "\n"
    line += "      " + "\n"
    line += "      //cleaning the vector array for new data" + "\n"
    line += "      for(int i=0; i<TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT; i++){" + "\n"
    line += "        TFValsPerPort[i].clear();" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      for (int idx=0; idx<TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT; idx++){  //loop through a group. A single 'Buf group' is 16 Bufs(HBM port width)." + "\n"
    line += "        int bufIdx = k*NUM_BUF_PER_PARA_LIMB_TF_PORT + s*TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT + idx;" + "\n"
    line += "        for(int i=0; i<TFValsPerBuf[bufIdx].size(); i++){ //loop through the values in the respective buf" + "\n"
    line += "          TFValsPerPort[idx].push_back(TFValsPerBuf[bufIdx][i]); //append it to respective stream" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      //calcualte the max length for this chain group" + "\n"
    line += "      int lastBufIdx = k*NUM_BUF_PER_PARA_LIMB_TF_PORT + s*TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT + TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT-1;" + "\n"
    line += "      int maxlength=FWD_NUM_TF_GRPS_PER_BUF[lastBufIdx]*beta; " + "\n"
    line += "" + "\n"
    line += "      //combining data into a WIDE stream" + "\n"
    line += "      for(int idx=0; idx<maxlength; idx++){" + "\n"
    line += "        TF_WIDE_DATA_PER_PARA_LIMB comb_data = 0;" + "\n"
    line += "        for(int bufIdx=TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT-1; bufIdx>=0; bufIdx--){" + "\n"
    line += "          comb_data <<= DRAM_WORD_SIZE;" + "\n"
    line += "          WORD small_data;" + "\n"
    line += "          if((idx+1)<=TFValsPerPort[bufIdx].size()){" + "\n"
    line += "            small_data = TFValsPerPort[bufIdx][idx];" + "\n"
    line += "          }" + "\n"
    line += "          else{" + "\n"
    line += "            small_data = 0;" + "\n"
    line += "          }" + "\n"
    line += "          comb_data |= (TF_WIDE_DATA_PER_PARA_LIMB)small_data;" + "\n"
    line += "        }" + "\n"
    line += "        outTFArr[k].push_back(comb_data);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    
    return line

def gen_inv_TF_data_rearrange():
    
    line = ""

    line += "//This function is used to reorganize TFs for INV transform in following conditions." + "\n"
    line += "//1. Only required TFs are stored" + "\n"
    line += "//2. One TF storage for 2 BUs with a distance of NUM_BU/2" + "\n"
    line += "//3. Chain broadcasting is used to load TFs." + "\n"
    line += "//4. Chain is for consecutive BUF modules. i.e., not balancing bandwdith" + "\n"
    line += "void inv_organizeTFData(std::vector<WORD>& inpTfArr, std::vector<TF_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<TF_WIDE_DATA_PER_PARA_LIMB>> (&outTFArr)[TF_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  std::vector<VAR_TYPE_32> TFGroupsPerBuf;" + "\n"
    line += "  std::vector<WORD> TFValsPerBuf[NUM_BU/2];" + "\n"
    line += "  std::vector<WORD> TFValsPerPort[TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT];" + "\n"
    line += "" + "\n"
    line += "  int beta = (N)/(2*NUM_BU);" + "\n"
    line += "  " + "\n"
    line += "  for (VAR_TYPE_32 bufIdx=0; bufIdx<NUM_BU/2; bufIdx++){ //loop through the TF buffers(1 Buf for 2 BUs)" + "\n"
    line += "    TFGroupsPerBuf.clear();" + "\n"
    line += "    //calculate TF group indexes" + "\n"
    line += "    for(VAR_TYPE_32 i=0; i<2; i++){ //loop through 2 BUs" + "\n"
    line += "      VAR_TYPE_32 BUIdx = bufIdx+(i*(NUM_BU/2)); //recreate target BU index" + "\n"
    line += "      for(VAR_TYPE_32 stage=logBU+2; stage>0; stage--){  //loop through bit size to extract different numbers created based on the BU index" + "\n"
    line += "        VAR_TYPE_32 tfGrpIdx = ((BUIdx) & (~((1<<(stage-1)) - 1)));" + "\n"
    line += "        TFGroupsPerBuf.push_back(tfGrpIdx);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "    //Sort and remove duplicate TF group indexes" + "\n"
    line += "    sort( TFGroupsPerBuf.begin(), TFGroupsPerBuf.end() );" + "\n"
    line += "    TFGroupsPerBuf.erase( unique( TFGroupsPerBuf.begin(), TFGroupsPerBuf.end() ), TFGroupsPerBuf.end() );" + "\n"
    line += "" + "\n"
    line += "    //adding TFs to respective Buf array based on the TF group index calculated before" + "\n"
    line += "    for(int numSets=0; numSets<TFGroupsPerBuf.size(); numSets++){" + "\n"
    line += "      int groupIndex = TFGroupsPerBuf[numSets];" + "\n"
    line += "      int TF_start_idx = groupIndex*beta;" + "\n"
    line += "      if( (numSets==((TFGroupsPerBuf.size()/2)-1)) || (numSets==(TFGroupsPerBuf.size()-1)) ){ //the middle one or the last one should have full group when supporting half distance BUs" + "\n"
    line += "        for(int idx=0; idx<beta; idx++){" + "\n"
    line += "          int tfIdx = TF_start_idx + idx;" + "\n"
    line += "          WORD tfVal = inpTfArr[tfIdx];" + "\n"
    line += "          TFValsPerBuf[bufIdx].push_back(tfVal);" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "      else{" + "\n"
    line += "        int tfIdx = TF_start_idx;" + "\n"
    line += "        WORD tfVal = inpTfArr[tfIdx];" + "\n"
    line += "        TFValsPerBuf[bufIdx].push_back(tfVal);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  //combining data for different DDR ports fascilitating chain broadcasting as well." + "\n"
    line += "  for(int k=0; k<TF_PORTS_PER_PARA_LIMB; k++){    // Number of HBM ports for TF. We use TF_PORTS_PER_PARA_LIMB as we support more buffers per port for TFs compared to polynomials." + "\n"
    line += "" + "\n"
    line += "    //putting all data that goes to this paerticular port into one vector array. They are inserted according to the chain broadcasting pattern" + "\n"
    line += "    for(int s=0; s<NUM_CHAIN_GROUPS_PER_PARA_LIMB_TF_PORT; s++){ // How many 'Bufs groups' being supported by a HBM prot. A single 'Buf group' is 8 Bufs(HBM port width)." + "\n"
    line += "      //cleaning the vector array for new data" + "\n"
    line += "      for(int i=0; i<TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT; i++){" + "\n"
    line += "        TFValsPerPort[i].clear();" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      for (int idx=0; idx<TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT; idx++){  //loop through a group. A single 'Buf group' is 16 Bufs(HBM port width)." + "\n"
    line += "        int bufIdx = k*NUM_BUF_PER_PARA_LIMB_TF_PORT + s*TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT + idx;" + "\n"
    line += "        for(int i=0; i<TFValsPerBuf[bufIdx].size(); i++){ //loop through the values in the respective buf" + "\n"
    line += "          TFValsPerPort[idx].push_back(TFValsPerBuf[bufIdx][i]); //append it to respective stream" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      //calcualte the max length for this port" + "\n"
    line += "      int lastBufIdx = k*NUM_BUF_PER_PARA_LIMB_TF_PORT + s*TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT + TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT-1;" + "\n"
    line += "      int maxlength = INV_NUM_TF_GRPS_PER_BUF[lastBufIdx]-2 + 2*beta;" + "\n"
    line += "" + "\n"
    line += "      //combining data into a WIDE stream" + "\n"
    line += "      for(int idx=0; idx<maxlength; idx++){" + "\n"
    line += "        TF_WIDE_DATA_PER_PARA_LIMB comb_data = 0;" + "\n"
    line += "        for(int bufIdx=TF_CONCAT_FACTOR_PER_PARA_LIMB_PORT-1; bufIdx>=0; bufIdx--){" + "\n"
    line += "          comb_data <<= DRAM_WORD_SIZE;" + "\n"
    line += "          WORD small_data;" + "\n"
    line += "          if((idx+1)<=TFValsPerPort[bufIdx].size()){" + "\n"
    line += "            small_data = TFValsPerPort[bufIdx][idx];" + "\n"
    line += "          }" + "\n"
    line += "          else{" + "\n"
    line += "            small_data = 0;" + "\n"
    line += "          }" + "\n"
    line += "          comb_data |= (TF_WIDE_DATA_PER_PARA_LIMB)small_data;" + "\n"
    line += "        }" + "\n"
    line += "        outTFArr[k].push_back(comb_data);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    
    return line

def gen_para_limbs_to_ports_TF_data_rearrange():
    line = ""

    line += "void reorganize_para_limbs_to_ports_tf(std::vector<TF_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<TF_WIDE_DATA_PER_PARA_LIMB>> (&inVec)[PARA_LIMBS][TF_PORTS_PER_PARA_LIMB], std::vector<TF_WIDE_DATA, tapa::aligned_allocator<TF_WIDE_DATA>> (&outVec)[TF_PORTS]){" + "\n"
    line += "" + "\n"
    line += "  for(int port_counter=0; port_counter<TF_PORTS; port_counter++){" + "\n"
    line += "    //init" + "\n"
    line += "    int target_per_limb_port_start = port_counter*PER_LIMB_PORTS_PER_TF_PORT;" + "\n"
    line += "    int target_limb_idx = target_per_limb_port_start/TF_PORTS_PER_PARA_LIMB;" + "\n"
    line += "    int target_limb_port_idx = target_per_limb_port_start%TF_PORTS_PER_PARA_LIMB;" + "\n"
    line += "" + "\n"
    line += "    int num_of_data = inVec[target_limb_idx][target_limb_port_idx].size();" + "\n"
    line += "    outVec[port_counter].resize(num_of_data);" + "\n"
    line += "" + "\n"
    line += "    //assign" + "\n"
    line += "    for(int data_counter=0; data_counter<num_of_data; data_counter++){" + "\n"
    line += "      TF_WIDE_DATA val = 0;" + "\n"
    line += "      for(int per_limb_port_counter=PER_LIMB_PORTS_PER_TF_PORT-1; per_limb_port_counter>=0; per_limb_port_counter--){" + "\n"
    line += "        int total_per_limb_ports = port_counter*PER_LIMB_PORTS_PER_TF_PORT + per_limb_port_counter;" + "\n"
    line += "        int limb_idx = total_per_limb_ports/TF_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        int limb_port_idx = total_per_limb_ports%TF_PORTS_PER_PARA_LIMB;" + "\n"
    line += "" + "\n"
    line += "        TF_WIDE_DATA_PER_PARA_LIMB limbVal;" + "\n"
    line += "        if(limb_idx<PARA_LIMBS){ " + "\n"
    line += "          limbVal = inVec[limb_idx][limb_port_idx][data_counter];" + "\n"
    line += "        }" + "\n"
    line += "        else{//In case, PARA_LIMBS is not perfectly divisible by PER_LIMB_PORTS_PER_TF_PORT" + "\n"
    line += "          limbVal = 0;" + "\n"
    line += "        }" + "\n"
    line += "        val = val << TF_DRAM_PORT_WIDTH_PER_PARA_LIMB;" + "\n"
    line += "        val |= (TF_WIDE_DATA)limbVal;" + "\n"
    line += "      }" + "\n"
    line += "      outVec[port_counter][data_counter] = val;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_input_tfs_to_ports(std::vector<WORD> (&inVec)[PARA_LIMBS], std::vector<TF_WIDE_DATA, tapa::aligned_allocator<TF_WIDE_DATA>> (&outVec)[TF_PORTS], bool direction){" + "\n"
    line += "  " + "\n"
    line += "  std::vector<TF_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<TF_WIDE_DATA_PER_PARA_LIMB>> limbWiseInTFData[PARA_LIMBS][TF_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  " + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    if(direction){" + "\n"
    line += "      fwd_organizeTFData(inVec[paraLimbCounter], limbWiseInTFData[paraLimbCounter]);" + "\n"
    line += "    }" + "\n"
    line += "    else{" + "\n"
    line += "      inv_organizeTFData(inVec[paraLimbCounter], limbWiseInTFData[paraLimbCounter]);" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "  reorganize_para_limbs_to_ports_tf(limbWiseInTFData, outVec);" + "\n"
    line += "" + "\n"
    line += "}" + "\n"

    return line

def gen_TF_data_rearrange_functions():
    line = ""

    # TF generation function
    line += gen_genTF_function()
    line += "\n"

    # FWD TF rearrange
    line += gen_fwd_TF_data_rearrange()
    line += "\n"

    # INV TF rearrange
    line += gen_inv_TF_data_rearrange()
    line += "\n"
    
    # Parallel limbs to TF ports rearrange
    line += gen_para_limbs_to_ports_TF_data_rearrange()
    line += "\n"

    return line