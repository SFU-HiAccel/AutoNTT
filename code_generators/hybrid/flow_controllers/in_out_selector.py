# Commenting this separate task and alligning this decision with split_shuffler
# # Similar to shuffler split logic in 'gen_shuffler_control' function, if the BUG is larger than 4x3, then split selector is used
# def gen_selector_split_logic(designParamsVar):
#     is_split_selector = False
#     if(designParamsVar.V_BUG_SIZE>8):
#         is_split_selector = True
#     return is_split_selector

def gen_comb_input_selector():
    line = ""
    line += "void input_selector(tapa::istreams<WORD, 2*V_BUG_SIZE>& fwd_valFromLoad," + "\n"
    line += "                   tapa::istreams<WORD, 2*V_BUG_SIZE>& fwd_valFromShuf," + "\n"
    line += "                   tapa::istreams<WORD, 2*V_BUG_SIZE>& inv_valFromBU," + "\n"
    line += "                  tapa::ostreams<WORD, 2*V_BUG_SIZE>& fwd_valToBU," + "\n"
    line += "                  tapa::ostreams<WORD, 2*V_BUG_SIZE>& inv_valToShuf," + "\n"
    line += "                  tapa::ostreams<WORD, 2*V_BUG_SIZE>& inv_valToStore," + "\n"
    line += "                  bool direction," + "\n"
    line += "                  VAR_TYPE_16 iter," + "\n"
    line += "                  VAR_TYPE_16 task_id){" + "\n"
    line += "" + "\n"
    line += "" + "\n"
    line += "  const VAR_TYPE_16 dataCount = (N/(V_TOTAL_DATA));" + "\n"
    line += "  const VAR_TYPE_8 dataFlowIterLimit = (VAR_TYPE_32)( (logN+(H_BUG_SIZE-1))/H_BUG_SIZE );" + "\n"
    line += "  " + "\n"
    line += "  WORD val;" + "\n"
    line += "" + "\n"
    line += "  bool inpStreamNotEmpty;" + "\n"
    line += "  for(VAR_TYPE_16 iterCount=0; iterCount<(iter+1); iterCount++){" + "\n"
    line += "    for(VAR_TYPE_8 dataFlowIter=0; dataFlowIter<dataFlowIterLimit; dataFlowIter++){" + "\n"
    line += "      for(VAR_TYPE_16 i=0; i<dataCount;){" + "\n"
    line += "        #pragma HLS PIPELINE II = 1" + "\n"
    line += "        if(direction){" + "\n"
    line += "          if(dataFlowIter==0){" + "\n"
    line += "            inpStreamNotEmpty = !fwd_valFromLoad[0].empty();" + "\n"
    line += "          }" + "\n"
    line += "          else{" + "\n"
    line += "            inpStreamNotEmpty = !fwd_valFromShuf[0].empty();" + "\n"
    line += "          }" + "\n"
    line += "          for(VAR_TYPE_8 j=1; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "            #pragma HLS UNROLL" + "\n"
    line += "            if(dataFlowIter==0){" + "\n"
    line += "              inpStreamNotEmpty &= !fwd_valFromLoad[j].empty();" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    line += "              inpStreamNotEmpty &= !fwd_valFromShuf[j].empty();" + "\n"
    line += "            }" + "\n"
    line += "          }" + "\n"
    line += "          if( inpStreamNotEmpty ){" + "\n"
    line += "            for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "              #pragma HLS UNROLL" + "\n"
    line += "              if(dataFlowIter==0){" + "\n"
    line += "                val = fwd_valFromLoad[j].read();" + "\n"
    line += "              }" + "\n"
    line += "              else{" + "\n"
    line += "                val = fwd_valFromShuf[j].read();" + "\n"
    line += "              }" + "\n"
    line += "              fwd_valToBU[j].write(val);" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          inpStreamNotEmpty = !inv_valFromBU[0].empty();" + "\n"
    line += "          for(VAR_TYPE_32 j=1; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "            inpStreamNotEmpty &= !inv_valFromBU[j].empty();" + "\n"
    line += "          }" + "\n"
    line += "          if(inpStreamNotEmpty){" + "\n"
    line += "            for(VAR_TYPE_32 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "              if( dataFlowIter == (dataFlowIterLimit-1) ){" + "\n"
    line += "                inv_valToStore[j].write(inv_valFromBU[j].read());" + "\n"
    line += "              }" + "\n"
    line += "              else{" + "\n"
    line += "                inv_valToShuf[j].write(inv_valFromBU[j].read());" + "\n"
    line += "              }" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_split_input_selector():
    line = ""
    line += "void  input_selector_single(" + "\n"
    line += "                    tapa::istream<WORD>& fwd_valFromLoad_0," + "\n"
    line += "                    tapa::istream<WORD>& fwd_valFromShuf," + "\n"
    line += "                    tapa::istream<WORD>& inv_valFromBU," + "\n"
    line += "                    tapa::ostream<WORD>& fwd_valToBU," + "\n"
    line += "                    tapa::ostream<WORD>& inv_valToShuf," + "\n"
    line += "                    tapa::ostream<WORD>& inv_valToStore_0," + "\n"
    line += "                    bool direction," + "\n"
    line += "                    VAR_TYPE_16 iter){" + "\n"
    line += "" + "\n"
    line += "" + "\n"
    line += "  const VAR_TYPE_16 dataCount = (N/(V_TOTAL_DATA));" + "\n"
    line += "  const VAR_TYPE_8 dataFlowIterLimit = (VAR_TYPE_8)( (logN+(H_BUG_SIZE-1))/H_BUG_SIZE );" + "\n"
    line += "  " + "\n"
    line += "  WORD val;" + "\n"
    line += "" + "\n"
    line += "  bool inpStreamNotEmpty;" + "\n"
    line += "  for(VAR_TYPE_16 iterCount=0; iterCount<(iter+1); iterCount++){" + "\n"
    line += "    for(VAR_TYPE_8 dataFlowIter=0; dataFlowIter<dataFlowIterLimit; dataFlowIter++){" + "\n"
    line += "      for(VAR_TYPE_16 i=0; i<dataCount;){" + "\n"
    line += "        #pragma HLS PIPELINE II = 1" + "\n"
    line += "        if(direction){" + "\n"
    line += "          if(dataFlowIter==0){" + "\n"
    line += "            inpStreamNotEmpty = !fwd_valFromLoad_0.empty();" + "\n"
    line += "          }" + "\n"
    line += "          else{" + "\n"
    line += "            inpStreamNotEmpty = !fwd_valFromShuf.empty();" + "\n"
    line += "          }" + "\n"
    line += "          if( inpStreamNotEmpty ){" + "\n"
    line += "            if(dataFlowIter==0){" + "\n"
    line += "              fwd_valToBU.write(fwd_valFromLoad_0.read());" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    line += "              fwd_valToBU.write(fwd_valFromShuf.read());" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          inpStreamNotEmpty = !inv_valFromBU.empty();" + "\n"
    line += "          if(inpStreamNotEmpty){" + "\n"
    line += "            if( dataFlowIter == (dataFlowIterLimit-1) ){" + "\n"
    line += "              inv_valToStore_0.write(inv_valFromBU.read());" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    line += "              inv_valToShuf.write(inv_valFromBU.read());" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_comb_output_selector():
    line = ""
    line += "void output_slector(tapa::istreams<WORD, 2*V_BUG_SIZE>& fwd_valFromBU," + "\n"
    line += "                  tapa::istreams<WORD, 2*V_BUG_SIZE>& inv_valFromLoad," + "\n"
    line += "                  tapa::istreams<WORD, 2*V_BUG_SIZE>& inv_valFromShuf," + "\n"
    line += "                  tapa::ostreams<WORD, 2*V_BUG_SIZE>& fwd_valToShuf," + "\n"
    line += "                  tapa::ostreams<WORD, 2*V_BUG_SIZE>& fwd_valToStore," + "\n"
    line += "                  tapa::ostreams<WORD, 2*V_BUG_SIZE>& inv_valToBU," + "\n"
    line += "                  bool direction," + "\n"
    line += "                  VAR_TYPE_16 iter," + "\n"
    line += "                  VAR_TYPE_16 task_id){" + "\n"
    line += "" + "\n"
    line += "" + "\n"
    line += "  const VAR_TYPE_16 dataCount = (N/(V_TOTAL_DATA));" + "\n"
    line += "  const VAR_TYPE_8 dataFlowIterLimit = (VAR_TYPE_32)( (logN+(H_BUG_SIZE-1))/H_BUG_SIZE );" + "\n"
    line += "  WORD val;" + "\n"
    line += "" + "\n"
    line += "  bool inpStreamNotEmpty;" + "\n"
    line += "  for(VAR_TYPE_16 iterCount=0; iterCount<(iter+1); iterCount++){" + "\n"
    line += "    for(VAR_TYPE_8 dataFlowIter=0; dataFlowIter<dataFlowIterLimit; dataFlowIter++){" + "\n"
    line += "      for(VAR_TYPE_16 i=0; i<dataCount;){" + "\n"
    line += "        #pragma HLS PIPELINE II = 1" + "\n"
    line += "        if(direction){" + "\n"
    line += "          inpStreamNotEmpty = !fwd_valFromBU[0].empty();" + "\n"
    line += "          for(VAR_TYPE_8 j=1; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "            inpStreamNotEmpty &= !fwd_valFromBU[j].empty();" + "\n"
    line += "          }" + "\n"
    line += "          if(inpStreamNotEmpty){" + "\n"
    line += "            for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "              #pragma HLS UNROLL" + "\n"
    line += "              val = fwd_valFromBU[j].read();" + "\n"
    line += "              if( dataFlowIter == (dataFlowIterLimit-1) ){" + "\n"
    line += "                fwd_valToStore[j].write(val);" + "\n"
    line += "              }" + "\n"
    line += "              else{" + "\n"
    line += "                fwd_valToShuf[j].write(val);" + "\n"
    line += "              }" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          if(dataFlowIter==0){" + "\n"
    line += "            inpStreamNotEmpty = !inv_valFromLoad[0].empty();" + "\n"
    line += "            for(VAR_TYPE_8 j=1; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "              inpStreamNotEmpty &= !inv_valFromLoad[j].empty();" + "\n"
    line += "            }" + "\n"
    line += "          }" + "\n"
    line += "          else{" + "\n"
    line += "            inpStreamNotEmpty = !inv_valFromShuf[0].empty();" + "\n"
    line += "            for(VAR_TYPE_8 j=1; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "              inpStreamNotEmpty &= !inv_valFromShuf[j].empty();" + "\n"
    line += "            }" + "\n"
    line += "          }" + "\n"
    line += "          if( inpStreamNotEmpty ){" + "\n"
    line += "            for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "              if(dataFlowIter==0){" + "\n"
    line += "                WORD temp_val = inv_valFromLoad[j].read();" + "\n"
    line += "                inv_valToBU[j].write(temp_val);" + "\n"
    line += "              }" + "\n"
    line += "              else{" + "\n"
    line += "                inv_valToBU[j].write(inv_valFromShuf[j].read());" + "\n"
    line += "              }" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_split_output_selector():
    line = ""
    line += "void output_slector_single(" + "\n"
    line += "                  tapa::istream<WORD>& fwd_valFromBU," + "\n"
    line += "                  tapa::istream<WORD>& inv_valFromLoad_0," + "\n"
    line += "                  tapa::istream<WORD>& inv_valFromShuf," + "\n"
    line += "                  tapa::ostream<WORD>& fwd_valToShuf," + "\n"
    line += "                  tapa::ostream<WORD>& fwd_valToStore_0," + "\n"
    line += "                  tapa::ostream<WORD>& inv_valToBU," + "\n"
    line += "                  bool direction," + "\n"
    line += "                  VAR_TYPE_16 iter){" + "\n"
    line += "" + "\n"
    line += "" + "\n"
    line += "  const VAR_TYPE_16 dataCount = (N/(V_TOTAL_DATA));" + "\n"
    line += "  const VAR_TYPE_8 dataFlowIterLimit = (VAR_TYPE_8)( (logN+(H_BUG_SIZE-1))/H_BUG_SIZE );" + "\n"
    line += "  WORD val;" + "\n"
    line += "" + "\n"
    line += "  bool inpStreamNotEmpty;" + "\n"
    line += "  for(VAR_TYPE_16 iterCount=0; iterCount<(iter+1); iterCount++){" + "\n"
    line += "    for(VAR_TYPE_8 dataFlowIter=0; dataFlowIter<dataFlowIterLimit; dataFlowIter++){" + "\n"
    line += "      for(VAR_TYPE_16 i=0; i<dataCount;){" + "\n"
    line += "        #pragma HLS PIPELINE II = 1" + "\n"
    line += "        if(direction){" + "\n"
    line += "          inpStreamNotEmpty = !fwd_valFromBU.empty();" + "\n"
    line += "" + "\n"
    line += "          if(inpStreamNotEmpty){" + "\n"
    line += "            if( dataFlowIter == (dataFlowIterLimit-1) ){" + "\n"
    line += "              fwd_valToStore_0.write(fwd_valFromBU.read());" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    line += "              fwd_valToShuf.write(fwd_valFromBU.read());" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          if(dataFlowIter==0){" + "\n"
    line += "            inpStreamNotEmpty = !inv_valFromLoad_0.empty();" + "\n"
    line += "          }" + "\n"
    line += "          else{" + "\n"
    line += "            inpStreamNotEmpty = !inv_valFromShuf.empty();" + "\n"
    line += "          }" + "\n"
    line += "" + "\n"
    line += "          if( inpStreamNotEmpty ){" + "\n"
    line += "            if(dataFlowIter==0){" + "\n"
    line += "              inv_valToBU.write(inv_valFromLoad_0.read());" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    line += "              inv_valToBU.write(inv_valFromShuf.read());" + "\n"
    line += "            }" + "\n"
    line += "            i++;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_input_selector(is_split_selector):
    line = ""
    if (is_split_selector):
        line = gen_split_input_selector()
    else:
        line = gen_comb_input_selector()
    return line

def gen_output_selector(is_split_selector):
    line = ""
    if (is_split_selector):
        line = gen_split_output_selector()
    else:
        line = gen_comb_output_selector()
    return line

def gen_in_out_selector(designParamsVar):
    line = ""
    is_split_selector = designParamsVar.IS_SPLIT_SHUFFLER # gen_selector_split_logic(designParamsVar)
    
    # generate input selector
    line += gen_input_selector(is_split_selector)

    # generate output selector
    line += gen_output_selector(is_split_selector)

    return line