# This function is to convert multiple parallel limbs into different DRAM ports.
# This function does not depend on FWD or INV
def gen_reorganize_para_limbs_to_ports_poly():
    
    line = ""

    line += "void reorganize_para_limbs_to_ports_poly(std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&inVec)[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB], std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&outVec)[POLY_LS_PORTS]){" + "\n"
    line += "  int num_of_data = ((N/V_TOTAL_DATA)*SEQ_BUG_PER_PARA_LIMB_POLY_PORT);" + "\n"
    line += "" + "\n"
    line += "  //check" + "\n"
    line += "  if(num_of_data!=(inVec[0][0].size())){" + "\n"
    line += "    printf(\"[ERROR]::Size mismatch detected in reorganize_para_limbs_to_ports_poly. expected = %d, received=%d\\n\", num_of_data, (int)(inVec[0][0].size()));" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  //init" + "\n"
    line += "  for(int port_idx=0; port_idx<POLY_LS_PORTS; port_idx++){" + "\n"
    line += "    outVec[port_idx].resize(num_of_data);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(int data_counter=0; data_counter<num_of_data; data_counter++){" + "\n"
    line += "    for(int port_counter=0; port_counter<POLY_LS_PORTS; port_counter++){" + "\n"
    line += "      POLY_WIDE_DATA val = 0;" + "\n"
    line += "      for(int per_limb_port_counter=PARA_LIMB_PORTS_PER_POLY_PORT-1; per_limb_port_counter>=0; per_limb_port_counter--){" + "\n"
    line += "        int total_per_limb_ports = port_counter*PARA_LIMB_PORTS_PER_POLY_PORT + per_limb_port_counter;" + "\n"
    line += "        int limb_idx = total_per_limb_ports/POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        int limb_port_idx = total_per_limb_ports%POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        " + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB limbVal;" + "\n"
    line += "        if(limb_idx<PARA_LIMBS){ " + "\n"
    line += "          limbVal = inVec[limb_idx][limb_port_idx][data_counter];" + "\n"
    line += "        }" + "\n"
    line += "        else{ //In case, PARA_LIMBS is not perfectly divisible by PARA_LIMB_PORTS_PER_POLY_PORT" + "\n"
    line += "          limbVal = 0;" + "\n"
    line += "        }" + "\n"
    line += "        val = val << POLY_DRAM_PORT_WIDTH_PER_PARA_LIMB;" + "\n"
    line += "        val |= (POLY_WIDE_DATA)limbVal;" + "\n"
    line += "      }" + "\n"
    line += "      outVec[port_counter][data_counter] = val;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

# This function is to convert different DRAM ports into multiple parallel limbs.
# This function does not depend on FWD or INV
def gen_reorganize_ports_to_para_limbs_poly():
    
    line = ""

    line += "void reorganize_ports_to_para_limbs_poly(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS], std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&outVec)[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  int num_of_data = ((N/V_TOTAL_DATA)*SEQ_BUG_PER_PARA_LIMB_POLY_PORT);" + "\n"
    line += "" + "\n"
    line += "  //check" + "\n"
    line += "  if(num_of_data!=(inVec[0].size())){" + "\n"
    line += "    printf(\"[ERROR]::Size mismatch detected in reorganize_para_limbs_to_ports_poly. expected = %d, received=%d\\n\", num_of_data, (int)(inVec[0].size()));" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  //init" + "\n"
    line += "  for(int limb_counter=0; limb_counter<PARA_LIMBS; limb_counter++){" + "\n"
    line += "    for(int port_counter=0; port_counter<POLY_LS_PORTS_PER_PARA_LIMB; port_counter++){" + "\n"
    line += "      outVec[limb_counter][port_counter].resize(num_of_data);" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(int data_counter=0; data_counter<num_of_data; data_counter++){" + "\n"
    line += "    for(int port_counter=0; port_counter<POLY_LS_PORTS; port_counter++){" + "\n"
    line += "      POLY_WIDE_DATA val = inVec[port_counter][data_counter];" + "\n"
    line += "      for(int per_limb_port_counter=0; per_limb_port_counter<PARA_LIMB_PORTS_PER_POLY_PORT; per_limb_port_counter++){" + "\n"
    line += "        int total_per_limb_ports = port_counter*PARA_LIMB_PORTS_PER_POLY_PORT + per_limb_port_counter;" + "\n"
    line += "        int limb_idx = total_per_limb_ports/POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        int limb_port_idx = total_per_limb_ports%POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        " + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB limbVal = val & (((POLY_WIDE_DATA)1 << POLY_DRAM_PORT_WIDTH_PER_PARA_LIMB)-1);" + "\n"
    line += "        val = val >> POLY_DRAM_PORT_WIDTH_PER_PARA_LIMB;" + "\n"
    line += "        if(limb_idx<PARA_LIMBS){  //In case, PARA_LIMBS is not perfectly divisible by PARA_LIMB_PORTS_PER_POLY_PORT(else of this if), we ignore extra data padded." + "\n"
    line += "          outVec[limb_idx][limb_port_idx][data_counter] = limbVal;" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

# This function is to initialize output DRAM ports to 0
def gen_init_kernerl_output_ports():

    line = ""

    line += "/* This function is to initialize output DRAM ports to 0 */" + "\n"
    line += "void init_kernerl_output_ports(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS]){" + "\n"
    line += "  for(int i=0; i<(N/V_TOTAL_DATA)*SEQ_BUG_PER_PARA_LIMB_POLY_PORT; i++){" + "\n"
    line += "    for(int j=0; j<POLY_LS_PORTS; j++){" + "\n"
    line += "      inVec[j].push_back(0);" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_fwd_poly_data_rearrange():
    line = ""

    line += "void fwd_blockWiseDivideData(std::vector<WORD>& inVec, std::vector<WORD> (&outVec)[V_TOTAL_DATA]){" + "\n"
    line += "  for(int i=0; i<N; i++){" + "\n"
    line += "    outVec[i%V_TOTAL_DATA].push_back(inVec[i]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void fwd_blockWiseCombineData(std::vector<WORD> (&inVec)[V_TOTAL_DATA], std::vector<WORD>& outVec){" + "\n"
    line += "" + "\n"
    line += "  std::vector<WORD> inputArr(2*V_BUG_SIZE);" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 lastSupportedStages = ( (logN%H_BUG_SIZE) == 0 ) ? (H_BUG_SIZE) : ( (logN%H_BUG_SIZE) ); " + "\n"
    line += "  VAR_TYPE_32 numOfPairsCombinedForStages = (1<<lastSupportedStages)/2;" + "\n"
    line += "  VAR_TYPE_32 numOfIndivCombinations = V_BUG_SIZE/numOfPairsCombinedForStages;" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 pairDistance = N/(1<<lastSupportedStages);" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<N/V_TOTAL_DATA; i++){" + "\n"
    line += "    for(int j=0; j<BUG_CONCAT_FACTOR; j++){" + "\n"
    line += "      " + "\n"
    line += "      for(int k=0; k<2*V_BUG_SIZE; k++){" + "\n"
    line += "        inputArr[k] = inVec[j*2*V_BUG_SIZE+k][i];" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      for(int grp_id=0; grp_id<numOfIndivCombinations ; grp_id++){" + "\n"
    line += "        for(int pair_id=0; pair_id<numOfPairsCombinedForStages; pair_id++){" + "\n"
    line += "          int val_addr0 = i*BUG_CONCAT_FACTOR*numOfIndivCombinations + \\" + "\n"
    line += "                          j + \\" + "\n"
    line += "                          grp_id*BUG_CONCAT_FACTOR + \\" + "\n"
    line += "                          pair_id*pairDistance*2;" + "\n"
    line += "          int val_addr1 = val_addr0 + pairDistance;" + "\n"
    line += "" + "\n"
    line += "          outVec[val_addr0] = inputArr[grp_id*numOfPairsCombinedForStages*2 + 2*pair_id];" + "\n"
    line += "          outVec[val_addr1] = inputArr[grp_id*numOfPairsCombinedForStages*2 + 2*pair_id + 1];" + "\n"
    line += "          " + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void fwd_reorganize_in_poly_per_para_limb(std::vector<WORD>& inVec, std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&outVec)[POLY_LS_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  std::vector<WORD> blockInData[V_TOTAL_DATA];" + "\n"
    line += "  fwd_blockWiseDivideData(inVec, blockInData);" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<POLY_LS_PORTS_PER_PARA_LIMB; i++){" + "\n"
    line += "    for(int j=0; j<(SEQ_BUG_PER_PARA_LIMB_POLY_PORT); j++){" + "\n"
    line += "      for(int k=0; k<N/V_TOTAL_DATA; k++){" + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB val = 0;" + "\n"
    line += "        for(int l=BUG_PER_PARA_LIMB_POLY_WIDE_DATA-1; l>=0; l--){" + "\n"
    line += "          for(int m=(POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA)-1; m>=0; m--){" + "\n"
    line += "            int blockIdx = ( ( i * (SEQ_BUG_PER_PARA_LIMB_POLY_PORT) + j ) * BUG_PER_PARA_LIMB_POLY_WIDE_DATA + l ) * (POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA) + m;" + "\n"
    line += "            val <<= DRAM_WORD_SIZE;" + "\n"
    line += "            val |= ((POLY_WIDE_DATA_PER_PARA_LIMB)blockInData[blockIdx][k]);" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "        outVec[i].push_back(val);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void fwd_reorganize_out_poly_per_para_limb(std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&inVec)[POLY_LS_PORTS_PER_PARA_LIMB], std::vector<WORD>& outVec){" + "\n"
    line += "  std::vector<WORD> blockOutData[V_TOTAL_DATA];" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<POLY_LS_PORTS_PER_PARA_LIMB; i++){" + "\n"
    line += "    for(int j=0; j<(SEQ_BUG_PER_PARA_LIMB_POLY_PORT); j++){" + "\n"
    line += "      for(int k=0; k<N/V_TOTAL_DATA; k++){" + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB val = inVec[i][j*N/V_TOTAL_DATA+k];" + "\n"
    line += "        for(int l=0; l<BUG_PER_PARA_LIMB_POLY_WIDE_DATA; l++){" + "\n"
    line += "          for(int m=0; m<(POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA); m++){" + "\n"
    line += "            int blockIdx = ( ( i * (SEQ_BUG_PER_PARA_LIMB_POLY_PORT) + j ) * BUG_PER_PARA_LIMB_POLY_WIDE_DATA + l ) * (POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA) + m;" + "\n"
    line += "            WORD smallData = val & ( (((POLY_WIDE_DATA_PER_PARA_LIMB)1) << WORD_SIZE) -1 );" + "\n"
    line += "            blockOutData[blockIdx].push_back(smallData);" + "\n"
    line += "            val = val >> DRAM_WORD_SIZE;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  fwd_blockWiseCombineData(blockOutData, outVec);" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void fwd_reorganize_input_poly_to_ports(std::vector<WORD> (&inVec)[PARA_LIMBS], std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&outVec)[POLY_LS_PORTS]){" + "\n"
    line += "  std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> limbWiseInPolyData[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  " + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    fwd_reorganize_in_poly_per_para_limb(inVec[paraLimbCounter], limbWiseInPolyData[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  reorganize_para_limbs_to_ports_poly(limbWiseInPolyData, outVec);" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void fwd_reorganize_ports_to_output_poly(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS], std::vector<WORD> (&outVec)[PARA_LIMBS]){" + "\n"
    line += "  std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> limbWiseOutData[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  reorganize_ports_to_para_limbs_poly(inVec, limbWiseOutData);" + "\n"
    line += "" + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    outVec[paraLimbCounter].resize(N);" + "\n"
    line += "    fwd_reorganize_out_poly_per_para_limb(limbWiseOutData[paraLimbCounter], outVec[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_inv_poly_data_rearrange():
    line = ""

    line += "void inv_blockWiseCombineData(std::vector<WORD> (&inVec)[V_TOTAL_DATA], std::vector<WORD>& outVec){" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<N/V_TOTAL_DATA; i++){" + "\n"
    line += "    for(int j=0; j<BUG_CONCAT_FACTOR; j++){" + "\n"
    line += "      for(int k=0; k<2*V_BUG_SIZE; k++){" + "\n"
    line += "        WORD val = inVec[j*2*V_BUG_SIZE+k][i];" + "\n"
    line += "        int val_addr = (i*BUG_CONCAT_FACTOR+j)*2*V_BUG_SIZE + k;" + "\n"
    line += "        outVec[val_addr] = val;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void inv_blockWiseDivideData(std::vector<WORD>& inVec, std::vector<WORD> (&outVec)[V_TOTAL_DATA]){" + "\n"
    line += "" + "\n"
    line += "  std::vector<WORD> inputArr(2*V_BUG_SIZE);" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 lastSupportedStages = ( (logN%H_BUG_SIZE) == 0 ) ? (H_BUG_SIZE) : ( (logN%H_BUG_SIZE) ); " + "\n"
    line += "  VAR_TYPE_32 numOfPairsCombinedForStages = (1<<lastSupportedStages)/2;" + "\n"
    line += "  VAR_TYPE_32 numOfIndivCombinations = V_BUG_SIZE/numOfPairsCombinedForStages;" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 pairDistance = N/(1<<lastSupportedStages);" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<N/V_TOTAL_DATA; i++){" + "\n"
    line += "    for(int j=0; j<BUG_CONCAT_FACTOR; j++){" + "\n"
    line += "      " + "\n"
    line += "      for(int grp_id=0; grp_id<numOfIndivCombinations ; grp_id++){" + "\n"
    line += "        for(int pair_id=0; pair_id<numOfPairsCombinedForStages; pair_id++){" + "\n"
    line += "          int val_addr0 = i*BUG_CONCAT_FACTOR*numOfIndivCombinations + \\" + "\n"
    line += "                          j + \\" + "\n"
    line += "                          grp_id*BUG_CONCAT_FACTOR + \\" + "\n"
    line += "                          pair_id*pairDistance*2;" + "\n"
    line += "          int val_addr1 = val_addr0 + pairDistance;" + "\n"
    line += "" + "\n"
    line += "          inputArr[grp_id*numOfPairsCombinedForStages*2 + 2*pair_id] = inVec[val_addr0];" + "\n"
    line += "          inputArr[grp_id*numOfPairsCombinedForStages*2 + 2*pair_id + 1] = inVec[val_addr1];" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      for(int k=0; k<2*V_BUG_SIZE; k++){" + "\n"
    line += "        outVec[j*2*V_BUG_SIZE+k].push_back(inputArr[k]);" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "// This function is complete inverse of fwd_reorganize_out_poly_per_para_limb." + "\n"
    line += "void inv_reorganize_in_poly_per_para_limb(std::vector<WORD>& inVec, std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&outVec)[POLY_LS_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  std::vector<WORD> blockInData[V_TOTAL_DATA];" + "\n"
    line += "" + "\n"
    line += "  inv_blockWiseDivideData(inVec, blockInData);" + "\n"
    line += "" + "\n"
    line += "  //init outVec" + "\n"
    line += "  for(int i=0; i<POLY_LS_PORTS_PER_PARA_LIMB; i++){" + "\n"
    line += "    outVec[i].resize((N/V_TOTAL_DATA)*SEQ_BUG_PER_PARA_LIMB_POLY_PORT);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<POLY_LS_PORTS_PER_PARA_LIMB; i++){" + "\n"
    line += "    for(int j=0; j<(SEQ_BUG_PER_PARA_LIMB_POLY_PORT); j++){" + "\n"
    line += "      for(int k=0; k<N/V_TOTAL_DATA; k++){" + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB val = 0;" + "\n"
    line += "        for(int l=BUG_PER_PARA_LIMB_POLY_WIDE_DATA-1; l>=0; l--){" + "\n"
    line += "          for(int m=(POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA)-1; m>=0; m--){" + "\n"
    line += "            val = val << DRAM_WORD_SIZE;" + "\n"
    line += "            int blockIdx = ( ( i * (SEQ_BUG_PER_PARA_LIMB_POLY_PORT) + j ) * BUG_PER_PARA_LIMB_POLY_WIDE_DATA + l ) * (POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA) + m;" + "\n"
    line += "            WORD smallData = blockInData[blockIdx][k];" + "\n"
    line += "            val = val | ((POLY_WIDE_DATA_PER_PARA_LIMB)smallData);" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "        outVec[i][j*N/V_TOTAL_DATA+k] = val;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void inv_reorganize_out_poly_per_para_limb(std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&inVec)[POLY_LS_PORTS_PER_PARA_LIMB], std::vector<WORD>& outVec){" + "\n"
    line += "  std::vector<WORD> blockOutData[V_TOTAL_DATA];" + "\n"
    line += "" + "\n"
    line += "  for(int i=0; i<POLY_LS_PORTS_PER_PARA_LIMB; i++){" + "\n"
    line += "    for(int j=0; j<(SEQ_BUG_PER_PARA_LIMB_POLY_PORT); j++){" + "\n"
    line += "      for(int k=0; k<N/V_TOTAL_DATA; k++){" + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB val = inVec[i][j*N/V_TOTAL_DATA+k];" + "\n"
    line += "        for(int l=0; l<BUG_PER_PARA_LIMB_POLY_WIDE_DATA; l++){" + "\n"
    line += "          for(int m=0; m<(POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA); m++){" + "\n"
    line += "            int blockIdx = ( ( i * (SEQ_BUG_PER_PARA_LIMB_POLY_PORT) + j ) * BUG_PER_PARA_LIMB_POLY_WIDE_DATA + l ) * (POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT/BUG_PER_PARA_LIMB_POLY_WIDE_DATA) + m;" + "\n"
    line += "            WORD smallData = val & ( (((POLY_WIDE_DATA_PER_PARA_LIMB)1) << WORD_SIZE) -1 );" + "\n"
    line += "            blockOutData[blockIdx].push_back(smallData);" + "\n"
    line += "            val = val >> DRAM_WORD_SIZE;" + "\n"
    line += "          }" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  inv_blockWiseCombineData(blockOutData, outVec);" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void inv_reorganize_input_poly_to_ports(std::vector<WORD> (&inVec)[PARA_LIMBS], std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&outVec)[POLY_LS_PORTS]){" + "\n"
    line += "  std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> limbWiseInPolyData[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  " + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    inv_reorganize_in_poly_per_para_limb(inVec[paraLimbCounter], limbWiseInPolyData[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  reorganize_para_limbs_to_ports_poly(limbWiseInPolyData, outVec);" + "\n"
    line += "}" + "\n"
    line += "" + "\n"
    
    line += "void inv_reorganize_ports_to_output_poly(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS], std::vector<WORD> (&outVec)[PARA_LIMBS]){" + "\n"
    line += "  std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> limbWiseOutData[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  reorganize_ports_to_para_limbs_poly(inVec, limbWiseOutData);" + "\n"
    line += "" + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    outVec[paraLimbCounter].resize(N);" + "\n"
    line += "    inv_reorganize_out_poly_per_para_limb(limbWiseOutData[paraLimbCounter], outVec[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_poly_data_rearrange_functions():
    line = ""

    # Parallel limbs to DRAM port conversion
    line += gen_reorganize_para_limbs_to_ports_poly()
    line += "\n"

    # DRAM port to parallel limbs conversion
    line += gen_reorganize_ports_to_para_limbs_poly()
    line += "\n"

    # FWD poly rearrange
    line += gen_fwd_poly_data_rearrange()
    line += "\n"

    # INV poly rearrange
    line += gen_inv_poly_data_rearrange()
    line += "\n"

    # Initialize output DRAM ports
    line += gen_init_kernerl_output_ports()
    line += "\n"

    return line