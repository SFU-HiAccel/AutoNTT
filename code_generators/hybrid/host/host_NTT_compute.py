def gen_CT_RToN_fwd_NTT():
    line = ""
    line += "void CT_RToN_fwd_NTT(std::vector<WORD>& inVec, std::vector<WORD>& tfVec, WORD mod, VAR_TYPE_32 size){" + "\n"
    line += "  for (VAR_TYPE_32 stage=1; stage<size; stage=stage*2){" + "\n"
    line += "    VAR_TYPE_32 distance = stage;" + "\n"
    line += "    VAR_TYPE_32 tableStep = size/(2*distance);" + "\n"
    line += "    for(VAR_TYPE_32 tableIdx = 0; tableIdx<size; tableIdx+=2*distance){" + "\n"
    line += "      VAR_TYPE_32 tfIdx = 0;" + "\n"
    line += "      for(VAR_TYPE_32 pairIdx=tableIdx; pairIdx<tableIdx+distance; pairIdx++){" + "\n"
    line += "        VAR_TYPE_32 leftIdx = pairIdx;" + "\n"
    line += "        VAR_TYPE_32 rightIdx = pairIdx+distance;" + "\n"
    line += "" + "\n"
    line += "        WORD left = inVec[leftIdx];" + "\n"
    line += "        WORD right = inVec[rightIdx];" + "\n"
    line += "        WORD tfVal = tfVec[tfIdx];" + "\n"
    line += "" + "\n"
    line += "        WORD reducedProduct = (WORD)((((DWORD)right) * ((DWORD)tfVal)) % ((DWORD)mod));" + "\n"
    line += "        " + "\n"
    line += "        WORD updatedLeft = (WORD)((((DWORD)left) + ((DWORD)reducedProduct)) % ((DWORD)mod));" + "\n"
    line += "        " + "\n"
    line += "        WORD updatedRight;" + "\n"
    line += "        if(left>=reducedProduct){" + "\n"
    line += "          updatedRight = left - reducedProduct;" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          updatedRight = mod - (reducedProduct - left);" + "\n"
    line += "        }" + "\n"
    line += "" + "\n"
    line += "        inVec[leftIdx] = updatedLeft;" + "\n"
    line += "        inVec[rightIdx] = updatedRight;" + "\n"
    line += "" + "\n"
    line += "        tfIdx += tableStep;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

def gen_CT_NToR_inv_NTT():
    line = ""
    line += "void CT_NToR_INTT(std::vector<WORD>& inVec, std::vector<WORD>& tfVec, WORD mod, VAR_TYPE_32 size){" + "\n"
    line += "  for (VAR_TYPE_32 stage=1; stage<size; stage=stage*2){" + "\n"
    line += "    VAR_TYPE_32 distance = size/(2*stage);" + "\n"
    line += "    VAR_TYPE_32 tfIdx = 0;" + "\n"
    line += "    for(VAR_TYPE_32 tableIdx = 0; tableIdx<size; tableIdx+=2*distance){" + "\n"
    line += "      for(VAR_TYPE_32 pairIdx=tableIdx; pairIdx<tableIdx+distance; pairIdx++){" + "\n"
    line += "        VAR_TYPE_32 leftIdx = pairIdx;" + "\n"
    line += "        VAR_TYPE_32 rightIdx = pairIdx+distance;" + "\n"
    line += "" + "\n"
    line += "        WORD left = inVec[leftIdx];" + "\n"
    line += "        WORD right = inVec[rightIdx];" + "\n"
    line += "        WORD tfVal = tfVec[tfIdx];" + "\n"
    line += "" + "\n"
    line += "        WORD reducedProduct = (WORD)((((DWORD)right) * ((DWORD)tfVal)) % ((DWORD)mod));" + "\n"
    line += "        " + "\n"
    line += "        WORD updatedLeft = (WORD)((((DWORD)left) + ((DWORD)reducedProduct)) % ((DWORD)mod));" + "\n"
    line += "        " + "\n"
    line += "        WORD updatedRight;" + "\n"
    line += "        if(left>=reducedProduct){" + "\n"
    line += "          updatedRight = left - reducedProduct;" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          updatedRight = mod - (reducedProduct - left);" + "\n"
    line += "        }" + "\n"
    line += "" + "\n"
    line += "        inVec[leftIdx] = updatedLeft;" + "\n"
    line += "        inVec[rightIdx] = updatedRight;" + "\n"
    line += "" + "\n"
    line += "      }" + "\n"
    line += "      tfIdx += 1;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  // multiply with (1/n) mod q, which is required in INTT" + "\n"
    line += "  WORD nInverse = (WORD)(mod_inverse_pow2Num(logN, (long)mod));" + "\n"
    line += "" + "\n"
    line += "  for(VAR_TYPE_32 i=0; i<size; i++){" + "\n"
    line += "    inVec[i] = (WORD)( (((DWORD)inVec[i]) * ((DWORD)nInverse)) % ((DWORD)mod) );" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

# This function generates CT data flow exactly same as CT_RToN_fwd_NTT, just without computations.
def gen_dummy_CT_RToN_fwd_NTT():
    line = ""
    line += "/* This function generates CT data flow exactly same as CT_RToN_fwd_NTT, just without computations. This can be used for debugging purposes */" + "\n"
    line += "void dummy_CT_RToN_fwd_NTT(std::vector<WORD>& inVec, std::vector<WORD>& tfVec, WORD mod, VAR_TYPE_32 size){" + "\n"
    line += "  for (VAR_TYPE_32 stage=1; stage<size; stage=stage*2){" + "\n"
    line += "    VAR_TYPE_32 distance = stage;" + "\n"
    line += "    VAR_TYPE_32 tableStep = size/(2*distance);" + "\n"
    line += "    for(VAR_TYPE_32 tableIdx = 0; tableIdx<size; tableIdx+=2*distance){" + "\n"
    line += "      VAR_TYPE_32 tfIdx = 0;" + "\n"
    line += "      for(VAR_TYPE_32 pairIdx=tableIdx; pairIdx<tableIdx+distance; pairIdx++){" + "\n"
    line += "        VAR_TYPE_32 leftIdx = pairIdx;" + "\n"
    line += "        VAR_TYPE_32 rightIdx = pairIdx+distance;" + "\n"
    line += "" + "\n"
    line += "        WORD left = inVec[leftIdx];" + "\n"
    line += "        WORD right = inVec[rightIdx];" + "\n"
    line += "" + "\n"
    line += "        inVec[leftIdx] = left;" + "\n"
    line += "        inVec[rightIdx] = right;" + "\n"
    line += "" + "\n"
    line += "        tfIdx += tableStep;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

def gen_host_NTT_compute_functions():

    line = ""

    # CT based NTT
    line += gen_CT_RToN_fwd_NTT()
    line += "\n"

    # CT based INTT
    line += gen_CT_NToR_inv_NTT()
    line += "\n"

    # CT based NTT dataflow w/o compute
    line += gen_dummy_CT_RToN_fwd_NTT()
    line += "\n"

    return line
