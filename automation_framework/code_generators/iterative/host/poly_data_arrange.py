def gen_in_poly_data_rearrange():
    line = ""

    line += "void blockWiseDivideData(std::vector<WORD>& inVec, std::vector<WORD> (&outVec)[NUM_BU]){" + "\n"
    line += "  for(int i=0; i<N; i++){" + "\n"
    line += "    outVec[i>>(logN-logBU)].push_back(inVec[i]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_in_poly_per_para_limb(std::vector<WORD>& inVec, std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&outVec)[POLY_LS_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  std::vector<WORD> blockInData[NUM_BU];" + "\n"
    line += "  blockWiseDivideData(inVec, blockInData);" + "\n"
    line += "" + "\n"
    line += "  for(int k=0; k<POLY_LS_PORTS_PER_PARA_LIMB; k++){    // Number of DRAM ports" + "\n"
    line += "    for(int s=0; s<NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT; s++){                     // How many 'Bufs groups' being supported by a DRAM prot. A single 'Buf group' is 8/16 Bufs(DRAM port width)." + "\n"
    line += "      for(int i=0; i<N/NUM_BU; i++){                   // How many values are being gone to a buf" + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB val = 0;" + "\n"
    line += "        for(int j=POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT-1; j>=0; j--){                // combine values in one buf group(8/16 bufs based on HBM width)" + "\n"
    line += "          val <<= DRAM_WORD_SIZE;" + "\n"
    line += "          val |= ((POLY_WIDE_DATA_PER_PARA_LIMB)blockInData[((k*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT+s)*POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT) + j][i]);" + "\n"
    line += "        }" + "\n"
    line += "        outVec[k].push_back(val);" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_para_limbs_to_ports_poly(std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&inVec)[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB], std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&outVec)[POLY_LS_PORTS]){" + "\n"
    line += "  int num_of_data = ((N*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT)/NUM_BU);" + "\n"
    line += "" + "\n"
    line += "  //check" + "\n"
    line += "  if(num_of_data!=(inVec[0][0].size())){" + "\n"
    line += "    printf(\"[ERROR]::Size mismatch detected in reorganize_para_limbs_to_ports_poly. expected = %d, received=%d\\n\", num_of_data, (int)(inVec[0][0].size()));" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  //init" + "\n"
    line += "  for(int port_idx=0; port_idx<POLY_LS_PORTS; port_idx++){" + "\n"
    line += "    outVec[port_idx].resize(num_of_data);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(int data_counter=0; data_counter<num_of_data; data_counter++){" + "\n"
    line += "    for(int port_counter=0; port_counter<POLY_LS_PORTS; port_counter++){" + "\n"
    line += "      POLY_WIDE_DATA val = 0;" + "\n"
    line += "      for(int per_limb_port_counter=PARA_LIMB_PORTS_PER_POLY_PORT-1; per_limb_port_counter>=0; per_limb_port_counter--){" + "\n"
    line += "        int total_per_limb_ports = port_counter*PARA_LIMB_PORTS_PER_POLY_PORT + per_limb_port_counter;" + "\n"
    line += "        int limb_idx = total_per_limb_ports/POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        int limb_port_idx = total_per_limb_ports%POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        " + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB limbVal;" + "\n"
    line += "        if(limb_idx<PARA_LIMBS){ " + "\n"
    line += "          limbVal = inVec[limb_idx][limb_port_idx][data_counter];" + "\n"
    line += "        }" + "\n"
    line += "        else{ //In case, PARA_LIMBS is not perfectly divisible by PARA_LIMB_PORTS_PER_POLY_PORT" + "\n"
    line += "          limbVal = 0;" + "\n"
    line += "        }" + "\n"
    line += "        val = val << POLY_DRAM_PORT_WIDTH_PER_PARA_LIMB;" + "\n"
    line += "        val |= (POLY_WIDE_DATA)limbVal;" + "\n"
    line += "      }" + "\n"
    line += "      outVec[port_counter][data_counter] = val;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_input_poly_to_ports(std::vector<WORD> (&inVec)[PARA_LIMBS], std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&outVec)[POLY_LS_PORTS]){" + "\n"
    line += "  std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> limbWiseInPolyData[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  " + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    reorganize_in_poly_per_para_limb(inVec[paraLimbCounter], limbWiseInPolyData[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  reorganize_para_limbs_to_ports_poly(limbWiseInPolyData, outVec);" + "\n"
    line += "}" + "\n"

    return line

def gen_out_poly_data_rearrange():
    line = ""

    line += "void init_kernerl_output_ports(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS]){" + "\n"
    line += "  for(int i=0; i<((N*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT)/NUM_BU); i++){" + "\n"
    line += "    for(int j=0; j<POLY_LS_PORTS; j++){" + "\n"
    line += "      inVec[j].push_back(0);" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void blockWiseCombineData(std::vector<WORD> (&inVec)[NUM_BU], std::vector<WORD>& outVec){" + "\n"
    line += "  for(int i=0; i<N; i++){" + "\n"
    line += "      outVec[i] = inVec[i >> (logN-logBU)][i & ((1U<<(logN-logBU))-1)];" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_out_poly_per_para_limb(std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&inVec)[POLY_LS_PORTS_PER_PARA_LIMB], std::vector<WORD>& outVec){" + "\n"
    line += "  std::vector<WORD> blockOutData[NUM_BU];" + "\n"
    line += "" + "\n"
    line += "  for(int k=0; k<POLY_LS_PORTS_PER_PARA_LIMB; k++){" + "\n"
    line += "    for(int s=0; s<NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT; s++){" + "\n"
    line += "      for(int i=0; i<N/NUM_BU; i++){" + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB val = inVec[k][(s*(N/NUM_BU)) + i];" + "\n"
    line += "        for(int j=0; j<POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT; j++){" + "\n"
    line += "          WORD smallVal = (WORD)(val & ((((POLY_WIDE_DATA_PER_PARA_LIMB)1)<<WORD_SIZE)-1));" + "\n"
    line += "          blockOutData[((k*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT+s)*POLY_CONCAT_FACTOR_PER_PARA_LIMB_PORT) + j].push_back(smallVal);" + "\n"
    line += "          val >>= DRAM_WORD_SIZE;" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "  " + "\n"
    line += "  blockWiseCombineData(blockOutData, outVec);" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_ports_to_para_limbs_poly(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS], std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> (&outVec)[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB]){" + "\n"
    line += "  int num_of_data = ((N*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT)/NUM_BU);" + "\n"
    line += "" + "\n"
    line += "  //check" + "\n"
    line += "  if(num_of_data!=(inVec[0].size())){" + "\n"
    line += "    printf(\"[ERROR]::Size mismatch detected in reorganize_para_limbs_to_ports_poly. expected = %d, received=%d\\n\", num_of_data, (int)(inVec[0].size()));" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  //init" + "\n"
    line += "  for(int limb_counter=0; limb_counter<PARA_LIMBS; limb_counter++){" + "\n"
    line += "    for(int port_counter=0; port_counter<POLY_LS_PORTS_PER_PARA_LIMB; port_counter++){" + "\n"
    line += "      outVec[limb_counter][port_counter].resize(num_of_data);" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(int data_counter=0; data_counter<num_of_data; data_counter++){" + "\n"
    line += "    for(int port_counter=0; port_counter<POLY_LS_PORTS; port_counter++){" + "\n"
    line += "      POLY_WIDE_DATA val = inVec[port_counter][data_counter];" + "\n"
    line += "      for(int per_limb_port_counter=0; per_limb_port_counter<PARA_LIMB_PORTS_PER_POLY_PORT; per_limb_port_counter++){" + "\n"
    line += "        int total_per_limb_ports = port_counter*PARA_LIMB_PORTS_PER_POLY_PORT + per_limb_port_counter;" + "\n"
    line += "        int limb_idx = total_per_limb_ports/POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        int limb_port_idx = total_per_limb_ports%POLY_LS_PORTS_PER_PARA_LIMB;" + "\n"
    line += "        " + "\n"
    line += "        POLY_WIDE_DATA_PER_PARA_LIMB limbVal = val & (((POLY_WIDE_DATA)1 << POLY_DRAM_PORT_WIDTH_PER_PARA_LIMB)-1);" + "\n"
    line += "        val = val >> POLY_DRAM_PORT_WIDTH_PER_PARA_LIMB;" + "\n"
    line += "        if(limb_idx<PARA_LIMBS){  //In case, PARA_LIMBS is not perfectly divisible by PARA_LIMB_PORTS_PER_POLY_PORT(else of this if), we ignore extra data padded." + "\n"
    line += "          outVec[limb_idx][limb_port_idx][data_counter] = limbVal;" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "// In the case of no double buffering, kernel share the same storage to save data with an offset. " + "\n"
    line += "// To streamline the ouput reordering for both double buffer enabled and disable cases," + "\n"
    line += "// this function rearrange the data removing the offset for double buffer disabled case." + "\n"
    line += "void remove_single_buffer_offset_in_output(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS]){" + "\n"
    line += "  for(int port_idx=0; port_idx<POLY_LS_PORTS; port_idx++){" + "\n"
    line += "    for(int data_idx=0; data_idx<((N/NUM_BU)*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT); data_idx++){" + "\n"
    line += "      inVec[port_idx][data_idx] = inVec[port_idx][data_idx+((N/NUM_BU)*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT)];" + "\n"
    line += "    }" + "\n"
    line += "    inVec[port_idx].resize(((N/NUM_BU)*NUM_CHAIN_GROUPS_PER_PARA_LIMB_POLY_PORT));" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "void reorganize_ports_to_output_poly(std::vector<POLY_WIDE_DATA, tapa::aligned_allocator<POLY_WIDE_DATA>> (&inVec)[POLY_LS_PORTS], std::vector<WORD> (&outVec)[PARA_LIMBS]){" + "\n"

    line += "  if(!DOUBLE_BUF_EN){" + "\n"
    line += "    remove_single_buffer_offset_in_output(inVec);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"

    line += "  std::vector<POLY_WIDE_DATA_PER_PARA_LIMB, tapa::aligned_allocator<POLY_WIDE_DATA_PER_PARA_LIMB>> limbWiseOutData[PARA_LIMBS][POLY_LS_PORTS_PER_PARA_LIMB];" + "\n"
    line += "  reorganize_ports_to_para_limbs_poly(inVec, limbWiseOutData);" + "\n"
    line += "" + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<PARA_LIMBS; paraLimbCounter++){" + "\n"
    line += "    outVec[paraLimbCounter].resize(N);" + "\n"
    line += "    reorganize_out_poly_per_para_limb(limbWiseOutData[paraLimbCounter], outVec[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

def gen_poly_data_rearrange_functions():
    line = ""

    # FWD poly rearrange
    line += gen_in_poly_data_rearrange()
    line += "\n"

    # INV poly rearrange
    line += gen_out_poly_data_rearrange()
    line += "\n"

    return line