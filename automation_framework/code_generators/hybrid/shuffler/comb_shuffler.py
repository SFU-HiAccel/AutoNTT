from code_generators.hybrid.shuffler.shuffler_in import gen_shuffler_in_config
from code_generators.hybrid.shuffler.shuffler_buf import gen_shuffler_buf_config
from code_generators.hybrid.shuffler.shuffler_out_shift import gen_shuffler_out_shift_config

def gen_comb_shuffler(designParamsVar):

  #generate shuffler in configurations
  shIn_log_shift_freq_table_output_str, shIn_log_mini_shift_reset_freq_table_output_str, shIn_log_mini_shift_amount_table_output_str, shIn_log_shift_jump_table_output_str = gen_shuffler_in_config(designParamsVar)

  #generate shuffler buf configurations
  shBuf_log_shift_freq_table_output_str, shBuf_log_mini_shift_reset_freq_table_output_str, shBuf_log_mini_shift_amount_table_output_str, shBuf_log_max_buf_offset_table_output_str, shBuf_shift_counts_table_output_str, shBuf_poly_group_line_offset_num_line_table_output_str, shBuf_log_poly_group_total_num_line_table_output_str, shBuf_log_out_data_cycles_per_bufGrp_table_output_str, shBuf_total_lines_in_group_mask_table_output_str = gen_shuffler_buf_config(designParamsVar)

  #generate suffler_out_shift configs
  shOut_log_shift_freq_table_output_str, shOut_log_mini_shift_reset_freq_table_output_str, shOut_log_mini_shift_amount_table_output_str, shOut_shift_counts_table_output_str = gen_shuffler_out_shift_config(designParamsVar)

  line = ""
  line += "void shuffler(tapa::istreams<WORD, 2*V_BUG_SIZE>& fwd_inVal," + "\n"
  line += "                  tapa::istreams<WORD, 2*V_BUG_SIZE>& inv_inVal," + "\n"
  line += "                   tapa::ostreams<WORD, 2*V_BUG_SIZE>& fwd_outVal," + "\n"
  line += "                   tapa::ostreams<WORD, 2*V_BUG_SIZE>& inv_outVal," + "\n"
  line += "                    bool direction," + "\n"
  line += "                   VAR_TYPE_16 BUG_id," + "\n"
  line += "                   VAR_TYPE_16 iter){" + "\n"
  line += "  " + "\n"
  line += "  WORD poly_buf[2*V_BUG_SIZE][2*SINGLE_LIMB_BUF_SIZE];" + "\n"
  line += "  #pragma HLS bind_storage variable=poly_buf type=RAM_S2P impl=BRAM latency=1" + "\n"
  line += "  #pragma HLS array_partition variable=poly_buf type=complete dim=1" + "\n"
  line += "" + "\n"
  line += "  const VAR_TYPE_16 dataCount = (N/(V_TOTAL_DATA));" + "\n"
  line += "  const VAR_TYPE_16 shuffleLimit = (VAR_TYPE_32)( (logN+(H_BUG_SIZE-1))/H_BUG_SIZE ) - 1;" + "\n"
  line += "" + "\n"
  line += "  VAR_TYPE_16 max_data_offset = (V_BUG_SIZE*2);" + "\n"
  line += "  " + "\n"
  line += "  //==== Auto generated variables start ====//" + "\n"
  line += "  VAR_TYPE_8 shIn_log_shift_freq_table[shuffleLimit] = " + shIn_log_shift_freq_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_8 shIn_log_mini_shift_reset_freq_table[shuffleLimit] = " + shIn_log_mini_shift_reset_freq_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_8 shIn_log_mini_shift_amount_table[shuffleLimit] = " + shIn_log_mini_shift_amount_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_8 shIn_log_shift_jump_table[shuffleLimit] = " + shIn_log_shift_jump_table_output_str + ";" + "\n"
  line += "" + "\n"
  line += "  VAR_TYPE_16 shBuf_log_shift_freq_table[shuffleLimit] = " + shBuf_log_shift_freq_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_log_mini_shift_reset_freq_table[shuffleLimit] = " + shBuf_log_mini_shift_reset_freq_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_log_mini_shift_amount_table[shuffleLimit] = " + shBuf_log_mini_shift_amount_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_log_max_buf_offset_table[shuffleLimit] = " + shBuf_log_max_buf_offset_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_shift_counts_table[shuffleLimit] = " + shBuf_shift_counts_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_poly_group_line_offset_num_line_table[shuffleLimit] = " + shBuf_poly_group_line_offset_num_line_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_log_poly_group_total_num_line_table[shuffleLimit] = " + shBuf_log_poly_group_total_num_line_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_log_out_data_cycles_per_bufGrp_table[shuffleLimit] = " + shBuf_log_out_data_cycles_per_bufGrp_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_16 shBuf_total_lines_in_group_mask_table[shuffleLimit] = " + shBuf_total_lines_in_group_mask_table_output_str + ";" + "\n"
  line += "" + "\n"
  line += "  VAR_TYPE_8 shOut_log_shift_freq_table[shuffleLimit] = " + shOut_log_shift_freq_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_8 shOut_log_mini_shift_reset_freq_table[shuffleLimit] = " + shOut_log_mini_shift_reset_freq_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_8 shOut_log_mini_shift_amount_table[shuffleLimit] = " + shOut_log_mini_shift_amount_table_output_str + ";" + "\n"
  line += "  VAR_TYPE_8 shOut_shift_counts_table[shuffleLimit] = " + shOut_shift_counts_table_output_str + ";" + "\n"
  line += "" + "\n"
  line += "  #pragma HLS array_partition variable=shIn_log_shift_freq_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shIn_log_mini_shift_reset_freq_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shIn_log_mini_shift_amount_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shIn_log_shift_jump_table type=complete dim=1" + "\n"
  line += "" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_log_shift_freq_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_log_mini_shift_reset_freq_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_log_mini_shift_amount_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_log_max_buf_offset_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_shift_counts_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_poly_group_line_offset_num_line_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_log_poly_group_total_num_line_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_log_out_data_cycles_per_bufGrp_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shBuf_total_lines_in_group_mask_table type=complete dim=1" + "\n"
  line += "" + "\n"
  line += "  #pragma HLS array_partition variable=shOut_log_shift_freq_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shOut_log_mini_shift_reset_freq_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shOut_log_mini_shift_amount_table type=complete dim=1" + "\n"
  line += "  #pragma HLS array_partition variable=shOut_shift_counts_table type=complete dim=1" + "\n"
  line += "  //==== Auto generated variables end ====//" + "\n"
  line += "" + "\n"
  line += "  VAR_TYPE_16 non_seq_idx[2*V_BUG_SIZE];" + "\n"
  line += "  WORD inValRegArr[2*V_BUG_SIZE];" + "\n"
  line += "  WORD shInBuf_RegArr[2*V_BUG_SIZE];" + "\n"
  line += "  WORD shBufShOut_RegArr[2*V_BUG_SIZE];" + "\n"
  line += "  WORD outValRegArr[2*V_BUG_SIZE];" + "\n"
  line += "  bool val_send_success[2*V_BUG_SIZE];" + "\n"
  line += "  VAR_TYPE_16 receiveCount[2];" + "\n"
  line += "  VAR_TYPE_16 sendCount[2];" + "\n"
  line += "  VAR_TYPE_8 shIn_mini_shift = 0;" + "\n"
  line += "  VAR_TYPE_8 shIn_major_shift = 0;" + "\n"
  line += "  VAR_TYPE_8 shIn_shift_amount = 0;" + "\n"
  line += "  VAR_TYPE_8 shOut_shift_amount = 0;" + "\n"
  line += "  VAR_TYPE_8 shOut_adjusted_shift_amount = 0;" + "\n"
  line += "" + "\n"
  line += "  ITER_LOOP:for(VAR_TYPE_16 iterCount=0; iterCount<(iter+1); iterCount++){" + "\n"
  line += "    " + "\n"
  line += "    for(VAR_TYPE_16 i=0; i<2; i++){" + "\n"
  line += "      #pragma HLS UNROLL" + "\n"
  line += "      receiveCount[i] = 0;" + "\n"
  line += "      sendCount[i] = 0;" + "\n"
  line += "    }" + "\n"
  line += "" + "\n"
  line += "    for(VAR_TYPE_16 i=0; i<2*V_BUG_SIZE; i++){" + "\n"
  line += "      val_send_success[i] = false;" + "\n"
  line += "    }" + "\n"
  line += "    bool all_val_send_success = true;" + "\n"
  line += "    VAR_TYPE_16 seq_idx;" + "\n"
  line += "" + "\n"
  line += "    VAR_TYPE_16 write_shuffler_id = 0;" + "\n"
  line += "    VAR_TYPE_16 read_shuffler_id = 0;" + "\n"
  line += "    VAR_TYPE_16 inv_write_shuffler_id = shuffleLimit - 1;" + "\n"
  line += "    VAR_TYPE_16 inv_read_shuffler_id = shuffleLimit - 1;" + "\n"
  line += "    VAR_TYPE_16 comp_write_shuffler_id = 0;" + "\n"
  line += "    VAR_TYPE_16 comp_read_shuffler_id = 0;" + "\n"
  line += "" + "\n"
  line += "    VAR_TYPE_16 shuffleCount = 0;" + "\n"
  line += "" + "\n"
  line += "    BUF_COMP:for(; shuffleCount<shuffleLimit ;){" + "\n"
  line += "      #pragma HLS PIPELINE II=1" + "\n"
  line += "" + "\n"
  line += "      if(direction){" + "\n"
  line += "        comp_read_shuffler_id = read_shuffler_id;" + "\n"
  line += "        comp_write_shuffler_id = write_shuffler_id;" + "\n"
  line += "      }" + "\n"
  line += "      else{" + "\n"
  line += "        comp_read_shuffler_id = inv_read_shuffler_id;" + "\n"
  line += "        comp_write_shuffler_id = inv_write_shuffler_id;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      VAR_TYPE_16 log_shift_freq;" + "\n"
  line += "      VAR_TYPE_16 log_mini_shift_reset_freq;" + "\n"
  line += "      VAR_TYPE_16 log_mini_shift_amount;" + "\n"
  line += "      VAR_TYPE_16 log_max_buf_offset;" + "\n"
  line += "      VAR_TYPE_16 shift_counts;" + "\n"
  line += "      VAR_TYPE_16 poly_group_line_offset_num_line;" + "\n"
  line += "      VAR_TYPE_16 log_poly_group_total_num_line;" + "\n"
  line += "      VAR_TYPE_16 log_out_data_cycles_per_bufGrp;" + "\n"
  line += "      VAR_TYPE_16 total_lines_in_group_mask;" + "\n"
  line += "" + "\n"
  line += "      VAR_TYPE_16 seq_addr_shuffler_id;" + "\n"
  line += "      VAR_TYPE_16 non_seq_addr_shuffler_id;" + "\n"
  line += "" + "\n"
  line += "      VAR_TYPE_16 seq_addr_count;" + "\n"
  line += "      VAR_TYPE_16 non_seq_addr_count;" + "\n"
  line += "" + "\n"
  line += "      if( direction ){" + "\n"
  line += "        seq_addr_shuffler_id = comp_write_shuffler_id;" + "\n"
  line += "        non_seq_addr_shuffler_id = comp_read_shuffler_id;" + "\n"
  line += "      }" + "\n"
  line += "      else{" + "\n"
  line += "        seq_addr_shuffler_id = comp_read_shuffler_id;" + "\n"
  line += "        non_seq_addr_shuffler_id = comp_write_shuffler_id;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      log_shift_freq = shBuf_log_shift_freq_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      log_mini_shift_reset_freq = shBuf_log_mini_shift_reset_freq_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      log_mini_shift_amount = shBuf_log_mini_shift_amount_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      log_max_buf_offset = shBuf_log_max_buf_offset_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      shift_counts = shBuf_shift_counts_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      poly_group_line_offset_num_line = shBuf_poly_group_line_offset_num_line_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      log_poly_group_total_num_line = shBuf_log_poly_group_total_num_line_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      log_out_data_cycles_per_bufGrp = shBuf_log_out_data_cycles_per_bufGrp_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      total_lines_in_group_mask = shBuf_total_lines_in_group_mask_table[non_seq_addr_shuffler_id];" + "\n"
  line += "" + "\n"
  line += "      for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "        #pragma HLS UNROLL" + "\n"
  line += "        if( (direction) && ( !val_send_success[local_buf_id] ) && (!all_val_send_success) && ( fwd_outVal[local_buf_id].try_write(outValRegArr[local_buf_id]) ) ){" + "\n"
  line += "          val_send_success[local_buf_id] = true;" + "\n"
  line += "        }" + "\n"
  line += "        else if( (!direction) && ( !val_send_success[local_buf_id] ) && (!all_val_send_success) && ( inv_outVal[local_buf_id].try_write(outValRegArr[local_buf_id]) ) ){" + "\n"
  line += "          val_send_success[local_buf_id] = true;" + "\n"
  line += "        }" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      bool all_stream_send_success = val_send_success[0];" + "\n"
  line += "      for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "        #pragma HLS UNROLL" + "\n"
  line += "        all_stream_send_success &= val_send_success[local_buf_id];" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      if(all_stream_send_success && (!all_val_send_success)){" + "\n"
  line += "        sendCount[comp_read_shuffler_id%2]++;" + "\n"
  line += "        all_val_send_success = true;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      if( direction ){" + "\n"
  line += "        seq_addr_count = receiveCount[comp_write_shuffler_id%2];" + "\n"
  line += "        non_seq_addr_count = sendCount[comp_read_shuffler_id%2];" + "\n"
  line += "      }" + "\n"
  line += "      else{" + "\n"
  line += "        seq_addr_count = sendCount[comp_read_shuffler_id%2];" + "\n"
  line += "        non_seq_addr_count = receiveCount[comp_write_shuffler_id%2];" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      VAR_TYPE_16 read_idx_poly_group_line_offset = ( ( non_seq_addr_count >> log_out_data_cycles_per_bufGrp) << (log_poly_group_total_num_line) ) & SINGLE_LIMB_BUF_SIZE_MASK;" + "\n"
  line += "      VAR_TYPE_16 cycle_start_idx_buffer_id = ( ( non_seq_addr_count >> (log_shift_freq - log_mini_shift_reset_freq) ) << (shift_counts + log_mini_shift_amount ) ) & ( (1<<log_max_buf_offset)-1 );" + "\n"
  line += "      VAR_TYPE_16 read_idx_iter_offset = ( non_seq_addr_count & ((1<<(log_shift_freq - log_mini_shift_reset_freq)) - 1) ) << log_mini_shift_reset_freq;" + "\n"
  line += "      VAR_TYPE_16 index_offset_based_on_strat_buffer = (poly_group_line_offset_num_line - cycle_start_idx_buffer_id);" + "\n"
  line += "" + "\n"
  line += "      seq_idx = (seq_addr_shuffler_id%2)*(SINGLE_LIMB_BUF_SIZE) +  seq_addr_count;" + "\n"
  line += "" + "\n"
  line += "      for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "        #pragma HLS UNROLL" + "\n"
  line += "        non_seq_idx[local_buf_id] = (non_seq_addr_shuffler_id%2)*(SINGLE_LIMB_BUF_SIZE) + \\" + "\n"
  line += "                (read_idx_poly_group_line_offset) + \\" + "\n"
  line += "                ( ( ( ( ( (local_buf_id + index_offset_based_on_strat_buffer) % (V_BUG_SIZE*2) ) >> (shift_counts + log_mini_shift_reset_freq + log_mini_shift_amount)) << log_shift_freq ) + \\" + "\n"
  line += "                ( ( ( ( local_buf_id + index_offset_based_on_strat_buffer ) % (V_BUG_SIZE*2)) & ( ( 1 << (log_mini_shift_reset_freq + log_mini_shift_amount) ) -1 ) ) >> (log_mini_shift_amount) ) ) & total_lines_in_group_mask ) + \\" + "\n"
  line += "                (read_idx_iter_offset);" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "        #pragma HLS UNROLL" + "\n"
  line += "        if(direction){" + "\n"
  line += "          shBufShOut_RegArr[local_buf_id] = poly_buf[local_buf_id][non_seq_idx[local_buf_id]];" + "\n"
  line += "        }" + "\n"
  line += "        else{" + "\n"
  line += "          shBufShOut_RegArr[local_buf_id] = poly_buf[local_buf_id][seq_idx];" + "\n"
  line += "        }" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      VAR_TYPE_16 shOut_log_shift_freq = shOut_log_shift_freq_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      VAR_TYPE_16 shOut_log_mini_shift_reset_freq = shOut_log_mini_shift_reset_freq_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      VAR_TYPE_16 shOut_log_mini_shift_amount = shOut_log_mini_shift_amount_table[non_seq_addr_shuffler_id];" + "\n"
  line += "      VAR_TYPE_16 shOut_shift_counts = shOut_shift_counts_table[non_seq_addr_shuffler_id];" + "\n"
  line += "" + "\n"
  line += "      VAR_TYPE_8 shIn_log_shift_freq = shIn_log_shift_freq_table[seq_addr_shuffler_id];" + "\n"
  line += "      VAR_TYPE_8 shIn_log_mini_shift_reset_freq = shIn_log_mini_shift_reset_freq_table[seq_addr_shuffler_id];" + "\n"
  line += "      VAR_TYPE_8 shIn_log_shift_jump = shIn_log_shift_jump_table[seq_addr_shuffler_id];" + "\n"
  line += "      VAR_TYPE_8 shIn_log_mini_shift_amount = shIn_log_mini_shift_amount_table[seq_addr_shuffler_id];" + "\n"
  line += "" + "\n"
  line += "      //Out shuffle" + "\n"
  line += "      shOut_shift_amount = ( ( non_seq_addr_count & ( (1<<(shOut_log_shift_freq-shOut_log_mini_shift_reset_freq)) - 1 ) ) == 0) ? ( ( max_data_offset - (((non_seq_addr_count >> (shOut_log_shift_freq-shOut_log_mini_shift_reset_freq)) << (shOut_shift_counts + shOut_log_mini_shift_amount)) % (max_data_offset)) ) % (max_data_offset) ) : (shOut_shift_amount);" + "\n"
  line += "" + "\n"
  line += "      //shuffle In process" + "\n"
  line += "      shIn_major_shift = ( ( seq_addr_count & ( (1<<shIn_log_shift_freq) - 1 ) ) == 0) ? (((seq_addr_count >> shIn_log_shift_freq) << shIn_log_shift_jump) % (max_data_offset)) : (shIn_major_shift);" + "\n"
  line += "      shIn_mini_shift = ( ( seq_addr_count & ( (1<<shIn_log_mini_shift_reset_freq) - 1 ) ) == 0 ) ? (0) : ( ( seq_addr_count & ( (1<<shIn_log_mini_shift_reset_freq) - 1 ) ) << shIn_log_mini_shift_amount );" + "\n"
  line += "" + "\n"
  line += "      if(direction){" + "\n"
  line += "        shOut_adjusted_shift_amount = shOut_shift_amount;" + "\n"
  line += "        shIn_shift_amount = shIn_major_shift + shIn_mini_shift;" + "\n"
  line += "      }" + "\n"
  line += "      else{" + "\n"
  line += "        shOut_adjusted_shift_amount = (max_data_offset - (shIn_major_shift + shIn_mini_shift))%max_data_offset;" + "\n"
  line += "        shIn_shift_amount = ( max_data_offset - shOut_shift_amount ) % max_data_offset;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      for(VAR_TYPE_16 j=0; j<V_BUG_SIZE*2; j++){" + "\n"
  line += "        #pragma HLS UNROLL" + "\n"
  line += "        outValRegArr[(j+shOut_adjusted_shift_amount)%max_data_offset] = shBufShOut_RegArr[j];" + "\n"
  line += "      }   " + "\n"
  line += "" + "\n"
  line += "      if( all_val_send_success && ( (receiveCount[comp_read_shuffler_id%2] >> log_poly_group_total_num_line) > (sendCount[comp_read_shuffler_id%2] >> log_poly_group_total_num_line) ) ){" + "\n"
  line += "        all_val_send_success = false;" + "\n"
  line += "        for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "          #pragma HLS UNROLL" + "\n"
  line += "          val_send_success[local_buf_id] = false;" + "\n"
  line += "        }" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      if(sendCount[comp_read_shuffler_id%2]==dataCount){" + "\n"
  line += "        sendCount[comp_read_shuffler_id%2] = 0;" + "\n"
  line += "        receiveCount[comp_read_shuffler_id%2] = 0;" + "\n"
  line += "        read_shuffler_id++;" + "\n"
  line += "        inv_read_shuffler_id--;" + "\n"
  line += "        shuffleCount++;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      //receive" + "\n"
  line += "      bool inFifoNotEmpty = ( !fwd_inVal[0].empty() ) || ( !inv_inVal[0].empty() ) ;" + "\n"
  line += "" + "\n"
  line += "      for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "        #pragma HLS UNROLL" + "\n"
  line += "        inFifoNotEmpty &= ( !fwd_inVal[local_buf_id].empty() ) || ( !inv_inVal[local_buf_id].empty() ) ;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      if(inFifoNotEmpty){" + "\n"
  line += "        for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
  line += "          #pragma HLS UNROLL" + "\n"
  line += "          if(direction){" + "\n"
  line += "            inValRegArr[j] = fwd_inVal[j].read();" + "\n"
  line += "          }" + "\n"
  line += "          else{" + "\n"
  line += "            inValRegArr[j] = inv_inVal[j].read();" + "\n"
  line += "          }" + "\n"
  line += "        }" + "\n"
  line += "" + "\n"
  line += "        //one cycle only shift" + "\n"
  line += "        for(VAR_TYPE_16 j=0; j<V_BUG_SIZE*2; j++){" + "\n"
  line += "          #pragma HLS UNROLL" + "\n"
  line += "          shInBuf_RegArr[(j+shIn_shift_amount)%max_data_offset] = inValRegArr[j];" + "\n"
  line += "        }" + "\n"
  line += "" + "\n"
  line += "        for(VAR_TYPE_16 local_buf_id=0; local_buf_id<2*V_BUG_SIZE; local_buf_id++){" + "\n"
  line += "          #pragma HLS UNROLL" + "\n"
  line += "            if(direction){" + "\n"
  line += "              poly_buf[local_buf_id][seq_idx] = shInBuf_RegArr[local_buf_id];" + "\n"
  line += "            }" + "\n"
  line += "            else{" + "\n"
  line += "              poly_buf[local_buf_id][non_seq_idx[local_buf_id]] = shInBuf_RegArr[local_buf_id];" + "\n"
  line += "            }" + "\n"
  line += "        }" + "\n"
  line += "        receiveCount[comp_write_shuffler_id%2]++;" + "\n"
  line += "      }" + "\n"
  line += "" + "\n"
  line += "      if( receiveCount[comp_write_shuffler_id%2] == dataCount ){ //received all the data in this iteration" + "\n"
  line += "        write_shuffler_id++;" + "\n"
  line += "        inv_write_shuffler_id = (inv_write_shuffler_id==0) ? (0) : inv_write_shuffler_id-1;" + "\n"
  line += "      }" + "\n"
  line += "    }" + "\n"
  line += "  }" + "\n"
  line += "}" + "\n"

  return line

def gen_shuffler_out_split(designParamsVar):
    
    #get number of inter BUG communication
    num_of_inter_BUG_comm = designParamsVar.NUM_INTER_BUG_COM

    line = ""
    line += "void shuffler_out_split(tapa::istreams<WORD, 2*V_BUG_SIZE>& fwd_inVal," + "\n"
    for comm_idx in range(num_of_inter_BUG_comm):
        line += "                        tapa::istreams<WORD, 2*V_BUG_SIZE>& inv_inVal_inter_" + str(comm_idx) + "," + "\n"
    line += "                        tapa::istreams<WORD, 2*V_BUG_SIZE>& inv_inVal_intra," + "\n"
    for comm_idx in range(num_of_inter_BUG_comm):
        line += "                        tapa::ostreams<WORD, 2*V_BUG_SIZE>& fwd_outVal_inter_" + str(comm_idx) + "," + "\n"
    line += "                        tapa::ostreams<WORD, 2*V_BUG_SIZE>& fwd_outVal_intra," + "\n"
    line += "                        tapa::ostreams<WORD, 2*V_BUG_SIZE>& inv_outVal," + "\n"
    line += "                        bool direction," + "\n"
    line += "                        VAR_TYPE_16 iter," + "\n"
    line += "                        VAR_TYPE_16 task_id){" + "\n"
    line += "  " + "\n"
    line += "  const VAR_TYPE_16 dataCount = (N/(V_TOTAL_DATA));" + "\n"
    line += "  const VAR_TYPE_8 shuffleLimit = (VAR_TYPE_8)( (logN+(H_BUG_SIZE-1))/H_BUG_SIZE ) - 1;" + "\n"
    line += "  VAR_TYPE_8 max_data_offset = (V_BUG_SIZE*2);" + "\n"
    line += "" + "\n"
    line += "  WORD inValRegArr[2*V_BUG_SIZE];" + "\n"
    line += "  WORD outValRegArr[2*V_BUG_SIZE];" + "\n"
    line += "" + "\n"
    line += "  bool inpStreamNotEmpty;" + "\n"
    line += "  VAR_TYPE_8 comp_shuffler_id;" + "\n"
    line += "  VAR_TYPE_8 shift_amount = 0;" + "\n"
    line += "  VAR_TYPE_8 adjusted_shift_amount = 0;" + "\n"
    line += "" + "\n"
    line += "  for(VAR_TYPE_16 iterCount=0; iterCount<(iter+1); iterCount++){" + "\n"
    line += "    for(VAR_TYPE_8 shuffler_id=0, inv_shuffler_id=shuffleLimit-1; shuffler_id<shuffleLimit; shuffler_id++, inv_shuffler_id--){" + "\n"
    line += "      OUT_SHUF_COMP:for(VAR_TYPE_16 i=0; i<dataCount;){" + "\n"
    line += "        #pragma HLS PIPELINE II = 1" + "\n"
    line += "" + "\n"
    line += "        if(direction){" + "\n"
    line += "          comp_shuffler_id = shuffler_id;" + "\n"
    line += "        }" + "\n"
    line += "        else{" + "\n"
    line += "          comp_shuffler_id = inv_shuffler_id;" + "\n"
    line += "        }" + "\n"
    line += "" + "\n"
    line += "        //read data from in stream" + "\n"
    line += "        inpStreamNotEmpty = ( !fwd_inVal[0].empty() ) "
    
    for comm_idx in range(num_of_inter_BUG_comm):
        line += "|| ( !inv_inVal_inter_" + str(comm_idx) + "[0].empty() ) " 

    line += "|| ( !inv_inVal_intra[0].empty() );" + "\n"
    line += "        for(VAR_TYPE_8 j=1; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "          inpStreamNotEmpty &= ( !fwd_inVal[j].empty() ) " 
    for comm_idx in range(num_of_inter_BUG_comm):
        line += "|| ( !inv_inVal_inter_" + str(comm_idx) + "[j].empty() ) " 
    line += "|| ( !inv_inVal_intra[j].empty() );" + "\n"
    line += "        }" + "\n"
    line += "" + "\n"
    line += "        if(inpStreamNotEmpty){" + "\n"
    line += "" + "\n"
    line += "          for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "            #pragma HLS UNROLL" + "\n"
    line += "            if(direction){" + "\n"
    line += "              inValRegArr[j] = fwd_inVal[j].read();" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    if(num_of_inter_BUG_comm==0):
        line += "              inValRegArr[j] = inv_inVal_intra[j].read();" + "\n"
    else:
        line += "              if(comp_shuffler_id==0){" + "\n"
        line += "                inValRegArr[j] = inv_inVal_inter_0[j].read();" + "\n"
        line += "              }" + "\n"

        for comm_idx in range(1, num_of_inter_BUG_comm):
            line += "              else if(comp_shuffler_id==" + str(comm_idx) + "){" + "\n"
            line += "                inValRegArr[j] = inv_inVal_inter_" + str(comm_idx) + "[j].read();" + "\n"
            line += "              }" + "\n"
        
        line += "              else{" + "\n"
        line += "                inValRegArr[j] = inv_inVal_intra[j].read();" + "\n"
        line += "              }" + "\n"
    line += "            }" + "\n"
    line += "          }" + "\n"
    line += "" + "\n"
    line += "          //forward" + "\n"
    line += "          for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "            #pragma HLS UNROLL" + "\n"
    line += "            outValRegArr[j] = inValRegArr[j];" + "\n"
    line += "          }" + "\n"
    line += "" + "\n"
    line += "          //write data to out stream" + "\n"
    line += "          for(VAR_TYPE_8 j=0; j<2*V_BUG_SIZE; j++){" + "\n"
    line += "            #pragma HLS UNROLL" + "\n"
    line += "            if(direction){" + "\n"
    if(num_of_inter_BUG_comm==0):
        line += "              fwd_outVal_intra[j].write(outValRegArr[j]);" + "\n"
    else:
        line += "              if(comp_shuffler_id==0){" + "\n"
        line += "                fwd_outVal_inter_0[j].write(outValRegArr[j]);" + "\n"
        line += "              }" + "\n"
        for comm_idx in range(1, num_of_inter_BUG_comm):
            line += "              else if(comp_shuffler_id==" + str(comm_idx) + "){" + "\n"
            line += "                fwd_outVal_inter_" + str(comm_idx) + "[j].write(outValRegArr[j]);" + "\n"
            line += "              }" + "\n"
        line += "              else{" + "\n"
        line += "                fwd_outVal_intra[j].write(outValRegArr[j]);" + "\n"
        line += "              }" + "\n"
    line += "            }" + "\n"
    line += "            else{" + "\n"
    line += "              inv_outVal[j].write(outValRegArr[j]);" + "\n"
    line += "            }" + "\n"
    line += "          }" + "\n"
    line += "          i++;" + "\n"
    line += "        }" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line

####
# Generate combined shuffler which include shuffler_in, shuffler_buf and shuffler_out_shift functionalities.
# shuffler_out_shuf0 and shuffler_out_shuf1 and tasks will be generated separately to handle inter BUG communications if it has any
####
def gen_comb_shuffler_tasks(designParamsVar):
    line = ""
    line += gen_comb_shuffler(designParamsVar)
    line += "\n"
    line += gen_shuffler_out_split(designParamsVar)
    line += "\n"
    return line