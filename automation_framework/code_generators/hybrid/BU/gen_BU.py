from code_generators.modmul.config import modmul_header_args
from code_generators.modmul.config import modmul_kernel_funcCall
from code_generators.modmul.config import NAIVE_RED, MONTGOMERY, BARRETT, WLM, CUSTOM_REDUCTION

####
# This task is to generate BU based on the different modulo reduction method
####
def gen_BU(designParamsVar):
    REDUCTION_TYPE = designParamsVar.REDUCTION_TYPE

    line = ""
    line += "void BU(" + "\n"
    line += "    tapa::istream<WORD>& fwd_inVal0, " + "\n"
    line += "    tapa::istream<WORD>& fwd_inVal1, " + "\n"
    line += "    tapa::istream<WORD>& inv_inVal0," + "\n"
    line += "    tapa::istream<WORD>& inv_inVal1, " + "\n"
    line += "    tapa::istream<WORD>& tf_inVal," + "\n"
    line += "    tapa::ostream<WORD>& fwd_outVal0," + "\n"
    line += "    tapa::ostream<WORD>& fwd_outVal1," + "\n"
    line += "    tapa::ostream<WORD>& inv_outVal0," + "\n"
    line += "    tapa::ostream<WORD>& inv_outVal1," + "\n"
    line += "    WORD q," + "\n"
    line += "    WORD twoInverse," + "\n"
    
    line += modmul_header_args(designParamsVar, "    ", ",\n")

    line += "    bool direction," + "\n"
    line += "    VAR_TYPE_16 iter," + "\n"
    line += "    VAR_TYPE_16 BUG_id," + "\n"
    line += "    VAR_TYPE_16 layer_id" + "\n"
    line += "    ){" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 totalIterDataCount = 0;" + "\n"
    line += "  VAR_TYPE_16 singleIterDataCount = 0;" + "\n"
    line += "  VAR_TYPE_32 totalIterDataLimit = (N/V_TOTAL_DATA) * ( (VAR_TYPE_32)(logN+(H_BUG_SIZE-1))/H_BUG_SIZE ) * (iter+1);" + "\n"
    line += "  VAR_TYPE_16 singleIterDataLimit = (N/V_TOTAL_DATA) * ( (VAR_TYPE_16)(logN+(H_BUG_SIZE-1))/H_BUG_SIZE );" + "\n"
    line += "  VAR_TYPE_16 nonCompleteStageLimit = ( (logN%H_BUG_SIZE) >= (layer_id+1) ) ? 1 : 0;" + "\n"
    line += "  VAR_TYPE_16 fwd_singleIterCompLimit = (N/V_TOTAL_DATA) * ( ((VAR_TYPE_16)logN/H_BUG_SIZE) + nonCompleteStageLimit );" + "\n"
    line += "  VAR_TYPE_16 inv_singleIterCompLimit = singleIterDataLimit - fwd_singleIterCompLimit;" + "\n"
    line += "" + "\n"
    line += "  WORD left;" + "\n"
    line += "  WORD right;" + "\n"
    line += "  WORD tfVal;" + "\n"
    line += "  WORD updatedLeft;" + "\n"
    line += "  WORD updatedRight;" + "\n"
    line += "" + "\n"
    line += "  BU_COMP:for (;totalIterDataCount<totalIterDataLimit; ) {" + "\n"
    line += "    #pragma HLS PIPELINE II=1" + "\n"
    line += "    if( ( ( ( (!fwd_inVal0.empty()) && (!fwd_inVal1.empty()) ) || ( (!inv_inVal0.empty()) && (!inv_inVal1.empty()) ) )  && ( !tf_inVal.empty() ) ) ){" + "\n"
    line += "      " + "\n"
    line += "      if(direction){" + "\n"
    line += "        left = fwd_inVal0.read();" + "\n"
    line += "        right = fwd_inVal1.read();" + "\n"
    line += "      }" + "\n"
    line += "      else{" + "\n"
    line += "        left = inv_inVal0.read();" + "\n"
    line += "        right = inv_inVal1.read();" + "\n"
    line += "      }" + "\n"
    line += "      tfVal = tf_inVal.read();" + "\n"
    line += "      " + "\n"
    
    line += modmul_kernel_funcCall(designParamsVar)

    line += "      WORD_PLUS1 intemAdd = reducedProduct + left;" + "\n"
    line += "      if(intemAdd>=q){" + "\n"
    line += "        updatedLeft = intemAdd - q;" + "\n"
    line += "      }" + "\n"
    line += "      else{" + "\n"
    line += "        updatedLeft = intemAdd;" + "\n"
    line += "      }" + "\n"
    line += "      " + "\n"
    line += "      if(left >= reducedProduct){" + "\n"
    line += "        updatedRight = left - reducedProduct;" + "\n"
    line += "      }" + "\n"
    line += "      else{" + "\n"
    line += "        updatedRight = q - (reducedProduct - left); " + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      if(!direction){ //Multiply with 2 inverse here. Equation=> (a>>1) + a[0]((mod+1)/2)" + "\n"
    line += "        multiplyTwoInverse(&updatedLeft, &twoInverse);" + "\n"
    line += "        multiplyTwoInverse(&updatedRight, &twoInverse);" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      if( ( (direction) && (singleIterDataCount >= fwd_singleIterCompLimit) ) || ( (!direction) && (singleIterDataCount < inv_singleIterCompLimit) ) ){" + "\n"
    line += "        updatedLeft = left;" + "\n"
    line += "        updatedRight = right;" + "\n"
    line += "      }" + "\n"
    line += "" + "\n"
    line += "      if(direction){" + "\n"
    line += "        fwd_outVal0.write(updatedLeft);" + "\n"
    line += "        fwd_outVal1.write(updatedRight);" + "\n"
    line += "      }" + "\n"
    line += "      else{" + "\n"
    line += "        inv_outVal0.write(updatedLeft);" + "\n"
    line += "        inv_outVal1.write(updatedRight);" + "\n"
    line += "      }" + "\n"
    line += "      " + "\n"
    line += "      totalIterDataCount++;" + "\n"
    line += "      singleIterDataCount = (singleIterDataCount==(singleIterDataLimit-1)) ? (0) : (singleIterDataCount+1);" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "}" + "\n"

    return line