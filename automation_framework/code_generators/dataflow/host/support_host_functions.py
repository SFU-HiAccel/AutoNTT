from code_generators.modmul.config import NAIVE_RED, MONTGOMERY, BARRETT, WLM, CUSTOM_REDUCTION
from code_generators.modmul.custom import gen_custom_red_mod_gen_host_func_def

def gen_find_NTT_friendly_modulus():
    line = ""
    line += "/*" + "\n"
    line += "Generate NTT friendly moduls." + "\n"
    line += "NTT friendly modulus is in the form of M = 2*n+1, n being the size of the input" + "\n"
    line += "*/" + "\n"
    line += "WORD find_NTT_friendly_modulus(WORD size, WORD minMod){" + "\n"
    line += "" + "\n"
    line += "  if ((size<1) | (minMod<1)){" + "\n"
    line += "    printf(\"[Error]::Double check your parameters\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  WORD start = (WORD)((minMod -1 + size -1)/size);" + "\n"
    line += "" + "\n"
    line += "  WORD multiplier = (start>((WORD)1))?start:(WORD)1;" + "\n"
    line += "" + "\n"
    line += "  while(true){" + "\n"
    line += "    WORD workModulus = size * multiplier + 1;" + "\n"
    line += "    if(workModulus<minMod){" + "\n"
    line += "      printf(\"[Error]::Something wrong. Double check.\\n\");" + "\n"
    line += "      exit(1);" + "\n"
    line += "    }" + "\n"
    line += "" + "\n"
    line += "    if(is_prime(workModulus)){" + "\n"
    line += "      return workModulus;" + "\n"
    line += "    }" + "\n"
    line += "    multiplier++;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

def gen_find_NTT_friendly_modulus_array():
    line = ""
    line += "/*" + "\n"
    line += "Generate NTT friendly moduls array." + "\n"
    line += "NTT friendly modulus is in the form of M = 2*n+1, n being the size of the input" + "\n"
    line += "*/" + "\n"
    line += "void find_NTT_friendly_modulus_array(WORD size, WORD minMod, std::vector<WORD>& modulusArray, VAR_TYPE_32 limbCount){" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 limbCounter = 0;" + "\n"
    line += "  for(VAR_TYPE_32 i=0; i<limbCount; i++){" + "\n"
    line += "    modulusArray[i] = 0;" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  if ((size<1) | (minMod<1)){" + "\n"
    line += "    printf(\"[Error]::Double check your parameters.\\n\");" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  WORD start = (WORD)((minMod -1 + size -1)/size);" + "\n"
    line += "" + "\n"
    line += "  WORD multiplier = (start>((WORD)1))?start:(WORD)1;" + "\n"
    line += "" + "\n"
    line += "  while(limbCounter < limbCount){" + "\n"
    line += "    WORD workModulus = size * multiplier + 1;" + "\n"
    line += "    if(workModulus<minMod){" + "\n"
    line += "      printf(\"[Error]::Something wrong. Double check.\\n\");" + "\n"
    line += "      exit(1);" + "\n"
    line += "    }" + "\n"
    line += "" + "\n"
    line += "    if(is_prime(workModulus)){" + "\n"
    line += "      // std::cout << \"modulusArray[\" << limbCounter << \"] = \" << workModulus << std::endl;" + "\n"
    line += "      modulusArray[limbCounter] = workModulus;" + "\n"
    line += "      limbCounter++;" + "\n"
    line += "    }" + "\n"
    line += "    multiplier++;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

def gen_find_NTT_and_WLM_friendly_modulus():
    line = ""
    line += "/*" + "\n"
    line += "Generate NTT and WLM friendly moduls." + "\n"
    line += "NTT friendly modulus is in the form of M = 2*N+1, N is the polynomial size." + "\n"
    line += "If WORD size for WLM is WLM_WORD_SIZE, for WLM (M-1)%(2^WLM_WORD_SIZE)=0 should satisfy." + "\n"
    line += "Since usually (2^WLM_WORD_SIZE) could be much larger than 2*N, we take specific measures to " + "\n"
    line += "find NTT and WLM friendly moduls here by making initial multiplier larger." + "\n"
    line += "*/" + "\n"
    line += "WORD find_NTT_and_WLM_friendly_modulus(WORD size, WORD minMod){" + "\n"
    line += "" + "\n"
    line += "  if ((size<1) | (minMod<1)){" + "\n"
    line += "    printf(\"[Error]::Double check your parameters\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  WORD start = (WORD)((minMod -1 + size -1)/size);" + "\n"
    line += "" + "\n"
    line += "  WORD multiplier = (((WORD_PLUS1)1)<<(WORD_SIZE-1))/(((WORD_PLUS1)1)<<WLM_WORD_SIZE);" + "\n"
    line += "" + "\n"
    line += "  while(true){" + "\n"
    line += "    WORD workModulus = (((WORD_PLUS1)1)<<WLM_WORD_SIZE) * multiplier + 1;" + "\n"
    line += "    if(workModulus<minMod){" + "\n"
    line += "      printf(\"[Error]::Something wrong. Double check.\\n\");" + "\n"
    line += "      exit(1);" + "\n"
    line += "    }" + "\n"
    line += "" + "\n"
    line += "    if(( ( (workModulus-1)%size ) == 0 ) ){" + "\n"
    line += "      if( is_prime(workModulus) ){" + "\n"
    line += "        return workModulus;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "" + "\n"
    line += "    multiplier++;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

def gen_find_NTT_and_WLM_friendly_modulus_array():
    line = ""
    line += "/*" + "\n"
    line += "Generate NTT friendly and WLM friendly moduls array." + "\n"
    line += "NTT friendly modulus is in the form of M = 2*N+1, N is the polynomial size." + "\n"
    line += "If WORD size for WLM is WLM_WORD_SIZE, for WLM (M-1)%(2^WLM_WORD_SIZE)=0 should satisfy." + "\n"
    line += "Since usually (2^WLM_WORD_SIZE) could be much larger than 2*N, we take specific measures to " + "\n"
    line += "find NTT and WLM friendly moduls here by making initial multiplier larger." + "\n"
    line += "*/" + "\n"
    line += "void find_NTT_and_WLM_friendly_modulus_array(WORD size, WORD minMod, std::vector<WORD>& modulusArray, VAR_TYPE_32 limbCount){" + "\n"
    line += "" + "\n"
    line += "  VAR_TYPE_32 limbCounter = 0;" + "\n"
    line += "  for(VAR_TYPE_32 i=0; i<limbCount; i++){" + "\n"
    line += "    modulusArray[i] = 0;" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  if ((size<1) | (minMod<1)){" + "\n"
    line += "    printf(\"[Error]::Double check your parameters.\\n\");" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  WORD start = (WORD)((minMod -1 + size -1)/size);" + "\n"
    line += "" + "\n"
    line += "  WORD multiplier = (((WORD_PLUS1)1)<<(WORD_SIZE-1))/(((WORD_PLUS1)1)<<WLM_WORD_SIZE);" + "\n"
    line += "" + "\n"
    line += "  while(limbCounter < limbCount){" + "\n"
    line += "    WORD workModulus = (((WORD_PLUS1)1)<<WLM_WORD_SIZE) * multiplier + 1;" + "\n"
    line += "    if(workModulus<minMod){" + "\n"
    line += "      printf(\"[Error]::Something wrong. Double check.\\n\");" + "\n"
    line += "      exit(1);" + "\n"
    line += "    }" + "\n"
    line += "" + "\n"
    line += "    if(( ( (workModulus-1)%size ) == 0 ) ){" + "\n"
    line += "      if(is_prime(workModulus)){" + "\n"
    line += "        //std::cout << \"modulusArray[\" << limbCounter << \"] = \" << workModulus << std::endl;" + "\n"
    line += "        modulusArray[limbCounter] = workModulus;" + "\n"
    line += "        limbCounter++;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "    multiplier++;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    return line

####
# This helps to generate supporting functions related to NTT
####
def gen_supporting_host_functions(designParamsVar):
    line = ""

    line += "/* Return x^p */" + "\n"
    line += "WORD myPow(WORD x, WORD p, WORD mod)" + "\n"
    line += "{" + "\n"
    line += "  if (p == 0) return 1;" + "\n"
    line += "  if (p == 1) return x % mod;" + "\n"
    line += "  " + "\n"
    line += "  WORD tmp = myPow(x, p/2, mod);" + "\n"
    line += "  WORD tmpSquare = (WORD)(((DWORD)(tmp) * (DWORD)(tmp)) % ((DWORD)mod));  //It is important to control the growth of values when multiplying. Hence, squaring is computed separately like this and used in later." + "\n"
    line += "  if (p%2 == 0){" + "\n"
    line += "    return tmpSquare;" + "\n"
    line += "  } " + "\n"
    line += "  else{" + "\n"
    line += "    WORD res = (WORD)(((DWORD)(x) * (DWORD)(tmpSquare)) % ((DWORD)mod));" + "\n"
    line += "    return res;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* calculate log2(NUM) */" + "\n"
    line += "VAR_TYPE_8 myLog2(WORD mod) {" + "\n"
    line += "    WORD result = 0;" + "\n"
    line += "    while (mod > 1) {" + "\n"
    line += "        mod >>= 1;" + "\n"
    line += "        result++;" + "\n"
    line += "    }" + "\n"
    line += "    return result;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Extended Euclidean algorithm to find modular inverse */" + "\n"
    line += "long extendedGCD(long a, long b, long &x, long &y) {" + "\n"
    line += "    if (b == 0) {" + "\n"
    line += "        x = 1;" + "\n"
    line += "        y = 0;" + "\n"
    line += "        return a;" + "\n"
    line += "    }" + "\n"
    line += "    long x1, y1;" + "\n"
    line += "    long gcd = extendedGCD(b, a % b, x1, y1);" + "\n"
    line += "    x = y1;" + "\n"
    line += "    y = x1 - (long)((a / b) * y1);" + "\n"
    line += "    return gcd;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Function to find modular inverse of 'a' modulo 'm' */" + "\n"
    line += "long mod_inverse(long a, long m) {" + "\n"
    line += "  " + "\n"
    line += "    long x, y;" + "\n"
    line += "    long gcd = extendedGCD(a, m, x, y);" + "\n"
    line += "    if (gcd != 1) {" + "\n"
    line += "        return 0; // Modular inverse does not exist" + "\n"
    line += "    } else {" + "\n"
    line += "        // Adjusting for negative result" + "\n"
    line += "        long res = (long)(x + (long)m);" + "\n"
    line += "        return ((res % m) + m) % m;" + "\n"
    line += "    }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Function to help finding inverse of Nth root of unity modulo m using specific " + "\n"
    line += "characteristics of primitive root of unity." + "\n"
    line += "Rules:" + "\n"
    line += "1. r^N mod m = 1" + "\n"
    line += "2. r^(N/2+k) mod m = -(r^k)" + "\n"
    line += "Idea:" + "\n"
    line += "* r^N mod m = 1 (rule 1)" + "\n"
    line += "* r^(N-1).r mod m = 1 -> Hence r^(N-1) = r^(-1)" + "\n"
    line += "* r^(N/2 + N/2 - 1).r mod m = 1" + "\n"
    line += "* r^(N/2 + N/2 - 1).r mod m = 1" + "\n"
    line += "* -r^(N/2 - 1).r mod m = 1 (rule 2) -> hence -r^(N/2 - 1) = r^(-1) */" + "\n"
    line += "WORD mod_inverse_root(WORD r, WORD m, VAR_TYPE_32 size){" + "\n"
    line += "  WORD inv = 1;" + "\n"
    line += "  for(int i=0; i<(size/2)-1; i++){" + "\n"
    line += "    inv = (WORD)((((DWORD)inv) * ((DWORD)r)) % ((DWORD)m));" + "\n"
    line += "  }" + "\n"
    line += "  inv = (WORD)(m - inv);" + "\n"
    line += "  return inv;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Function to help finding inverse of power of 2 numbers using the fact that n = 2^x." + "\n"
    line += "Idea:" + "\n"
    line += "* n^(-1) = (2^x)^(-1) = (2^(-1))^(x) */" + "\n"
    line += "WORD mod_inverse_pow2Num(VAR_TYPE_32 logx, WORD m){" + "\n"
    line += "  WORD inv = 1;" + "\n"
    line += "  WORD twoInverse = (m+1)/2;" + "\n"
    line += "  for(int i=0; i<logx; i++){" + "\n"
    line += "    inv = (WORD)((((DWORD)inv) * ((DWORD)twoInverse)) % ((DWORD)m));" + "\n"
    line += "  }" + "\n"
    line += "  return inv;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Get the length of mod number */" + "\n"
    line += "VAR_TYPE_8 bit_length(WORD mod) {" + "\n"
    line += "    VAR_TYPE_8 result = 0;" + "\n"
    line += "    while (mod > 0) { //works for mod as it is an odd number(prime)." + "\n"
    line += "        mod >>= 1;" + "\n"
    line += "        result++;" + "\n"
    line += "    }" + "\n"
    line += "    return result;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Initialize array to 0 for given size */" + "\n"
    line += "void initializeArr(std::vector<WORD>& vec, WORD size){" + "\n"
    line += "  for(int i=0; i<size; i++){" + "\n"
    line += "    vec[i] = 0;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Generate an input for the ntt computation" + "\n"
    line += "seed - Seed for random number generator" + "\n"
    line += "minMod -  minimum working modulus" + "\n"
    line += "size -  Size of the input. Has to be some 2 to the power number(need to add a check)" + "\n"
    line += "invec - Generated polynomial" + "\n"
    line += "*/" + "\n"
    line += "void gen_random_arr(VAR_TYPE_32 seed, WORD minMod, WORD size, std::vector<WORD>& invec){" + "\n"
    line += "  " + "\n"
    line += "  std::srand(seed);" + "\n"
    line += "" + "\n"
    line += "  for (int i=0; i < size; i++){" + "\n"
    line += "    invec[i] = std::rand() % minMod;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"
    
    line += "/* Return floor(sqrt(num)) */" + "\n"
    line += "WORD floor_sqrt(WORD num){" + "\n"
    line += "  VAR_TYPE_64 val = (VAR_TYPE_64)(floor(sqrt((VAR_TYPE_64)num)));" + "\n"
    line += "  WORD returnVal = *(WORD*)(&val);" + "\n"
    line += "  return returnVal;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Test whether the given integer is a prime */" + "\n"
    line += "bool is_prime(WORD num){" + "\n"
    line += "  if (num <= 1){" + "\n"
    line += "    printf(\"[Error]::Value is less than 1.\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  WORD limit = floor_sqrt(num) + 1;" + "\n"
    line += "" + "\n"
    line += "  for (VAR_TYPE_64 i=2; i<limit; i++){" + "\n"
    line += "    if(num%i==0){" + "\n"
    line += "      return false;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "  return true;" + "\n"
    line += "" + "\n"
    line += "}" + "\n"
    line += "" + "\n"
    
    if( designParamsVar.REDUCTION_TYPE==WLM ):
        line += gen_find_NTT_and_WLM_friendly_modulus()
        line += "\n"
        line += gen_find_NTT_and_WLM_friendly_modulus_array()
    elif( designParamsVar.REDUCTION_TYPE==CUSTOM_REDUCTION ):
        custom_mod_gen_code = gen_custom_red_mod_gen_host_func_def(designParamsVar)
        if(custom_mod_gen_code==""): # if empty, use default ones
            line += gen_find_NTT_friendly_modulus()
            line += "\n"
            line += gen_find_NTT_friendly_modulus_array()
        else:
            line += custom_mod_gen_code
    else:
        line += gen_find_NTT_friendly_modulus()
        line += "\n"
        line += gen_find_NTT_friendly_modulus_array()
    
    line += "" + "\n"
    line += "/*" + "\n"
    line += "Returns a list of unique prime factors of the given integer in" + "\n"
    line += "ascending order. For example, unique_prime_factors(60) = [2, 3, 5]." + "\n"
    line += "*/" + "\n"
    line += "void unique_prime_factors(WORD val, std::vector<WORD>& unique_factors){" + "\n"
    line += "  if(val<1){" + "\n"
    line += "    printf(\"[Error]::Invalid number to find unique primes\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  WORD factor = 2;" + "\n"
    line += "  WORD fact_end = floor_sqrt(val);" + "\n"
    line += "" + "\n"
    line += "  while(factor <= fact_end){" + "\n"
    line += "    if(val % factor == 0){" + "\n"
    line += "      unique_factors.push_back(factor);" + "\n"
    line += "      val = (WORD)(val/factor);" + "\n"
    line += "      " + "\n"
    line += "      while(val % factor == 0){" + "\n"
    line += "        val = (WORD)(val/factor);" + "\n"
    line += "      }" + "\n"
    line += "      fact_end = floor_sqrt(val);" + "\n"
    line += "    }" + "\n"
    line += "    factor++;" + "\n"
    line += "  }" + "\n"
    line += "  if(val>1){" + "\n"
    line += "    unique_factors.push_back(val);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/*" + "\n"
    line += "Check if the passed values is a degreeth primitive root of unity in modulo mod." + "\n"
    line += "Conditions for primitive root: val^degree % mod = 1 and for all 1 <= k < degree, val^k % mod != 1" + "\n"
    line += "*/" + "\n"
    line += "bool is_primitive_root(WORD val, WORD degree, WORD mod){" + "\n"
    line += "  if ((val < 0) | (val > mod)){" + "\n"
    line += "    printf(\"[Error]::Check the passed value\\n\");" + "\n"
    line += "  }" + "\n"
    line += "  if ((degree<1) | (degree>mod)){" + "\n"
    line += "    printf(\"[Error]::Check the passed value\\n\");" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  std::vector<WORD> prime_factors;" + "\n"
    line += "  unique_prime_factors(degree, prime_factors);" + "\n"
    line += "" + "\n"
    line += "  if((myPow(val, degree, mod)) == 1){" + "\n"
    line += "    for(int i=0; i<prime_factors.size(); i++){" + "\n"
    line += "      WORD newDeg = (WORD)(degree/prime_factors[i]);" + "\n"
    line += "      if((myPow(val, newDeg, mod)) == 1){" + "\n"
    line += "        return false;" + "\n"
    line += "      }" + "\n"
    line += "    }" + "\n"
    line += "    return true;" + "\n"
    line += "  }" + "\n"
    line += "  else{" + "\n"
    line += "    return false;" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Returns an arbitrary generator of the multiplicative group of integers modulo mod." + "\n"
    line += "totient must equal the Euler phi function of mod. If mod is prime, an answer must exist. */" + "\n"
    line += "WORD find_generator(WORD totient, WORD mod){" + "\n"
    line += "  if((totient<1) | (totient>=mod)){" + "\n"
    line += "    printf(\"[Error]::Issue in inputs to find_generator\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(WORD i=1; i<mod; i++){" + "\n"
    line += "    if(is_primitive_root(i, totient, mod)){" + "\n"
    line += "      return i;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "  printf(\"[Error]::No generators found\\n\");" + "\n"
    line += "  exit(1);" + "\n"
    line += "  return 0;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Provide the bit reveresed value." + "\n"
    line += "i.e., bitReverseNumber(3,3) = 6 = 110 (= reverse(011) = reverse(3)))" + "\n"
    line += "*/" + "\n"
    line += "WORD bitReverseNumber(WORD num, WORD bits){" + "\n"
    line += "  WORD temp = 0;" + "\n"
    line += "  for(int i=0; i<bits; i++){" + "\n"
    line += "    temp = (temp<<1) | (num & 1);" + "\n"
    line += "    num >>= 1;" + "\n"
    line += "  }" + "\n"
    line += "  return temp;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Generate the bit reveresed array */" + "\n"
    line += "void bitReverseVect(std::vector<WORD>& vec, WORD size){" + "\n"
    line += "  WORD levels = myLog2(size);" + "\n"
    line += "  if((1<<levels) != size){" + "\n"
    line += "    printf(\"[Error]::Length is not a power of 2.\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  for(WORD i=0; i<size; i++){" + "\n"
    line += "    WORD j = bitReverseNumber(i,levels);" + "\n"
    line += "    if(j>i){" + "\n"
    line += "      WORD temp = vec[i];" + "\n"
    line += "      vec[i] = vec[j];" + "\n"
    line += "      vec[j] = temp;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Returns an arbitrary primitive degree-th root of unity modulo mod." + "\n"
    line += "totient must be a multiple of degree. If mod is prime, an answer must exist." + "\n"
    line += "*/" + "\n"
    line += "WORD find_primitive_root(WORD degree, WORD totient, WORD mod){" + "\n"
    line += "  if((degree<1) | (totient<1) | (totient<degree) | (mod<degree) | (mod<totient)) {" + "\n"
    line += "    printf(\"[Error]::Error in the inputs in find_primitive_root\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "  if(totient%degree!=0){" + "\n"
    line += "    printf(\"[Error]::Invalid totient or degree passed to find_primitive_root\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "  WORD gen = find_generator(totient, mod);" + "\n"
    line += "  WORD root = myPow(gen, (WORD)(totient/degree), mod);" + "\n"
    line += "" + "\n"
    line += "  if((root<0) | (root>mod)){" + "\n"
    line += "    printf(\"[Error]::Error in generated root\\n\");" + "\n"
    line += "    exit(1);" + "\n"
    line += "  }" + "\n"
    line += "" + "\n"
    line += "  return root;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"
    
    line += "/* Compare values of two arrays and check correctness */" + "\n"
    line += "bool compareResults(std::vector<WORD>& ref, std::vector<WORD>& test, WORD size){" + "\n"
    line += "  for(int i=0; i<size; i++){" + "\n"
    line += "    if(ref[i]!=test[i]){" + "\n"
    line += "      std::cout << \"Error detected at idx=\" << i << \", ref=\" << ref[i] << \", test=\" << test[i] << std::endl;" + "\n"
    line += "      return false;" + "\n"
    line += "    }" + "\n"
    line += "  }" + "\n"
    line += "  return true;" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "/* Generate polynomials with random values. Each coefficient is within log(q) range*/" + "\n"
    line += "void generate_random_polynomials_array(VAR_TYPE_32 seed, VAR_TYPE_64 minMod, VAR_TYPE_32 size, VAR_TYPE_32 para_limbs, std::vector<WORD> (&invec)[PARA_LIMBS]){" + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<para_limbs; paraLimbCounter++){" + "\n"
    line += "    invec[paraLimbCounter].resize(size);" + "\n"
    line += "    initializeArr(invec[paraLimbCounter], size);" + "\n"
    line += "    gen_random_arr((seed+paraLimbCounter), minMod, size, invec[paraLimbCounter]);" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"
    line += "" + "\n"

    line += "// Generate the primitive root of unity, inverse root and two inverse (used in INTT)" + "\n"
    line += "void generate_NTT_variables(std::vector<WORD>& workingModulus_arr, VAR_TYPE_32 size, VAR_TYPE_32 para_limbs, std::vector<WORD>& root_arr, std::vector<WORD>& rootInverse_arr, std::vector<WORD>& twoInverse_arr){" + "\n"
    line += "  for(VAR_TYPE_32 paraLimbCounter=0; paraLimbCounter<para_limbs; paraLimbCounter++){" + "\n"
    line += "    WORD workingModulus = workingModulus_arr[paraLimbCounter];" + "\n"
    line += "    " + "\n"
    line += "    WORD root = find_primitive_root(size, workingModulus-1, workingModulus);" + "\n"
    line += "    WORD rootInverse = (WORD)(mod_inverse_root((long)root, (long)workingModulus, size));" + "\n"
    line += "    WORD twoInverse = (workingModulus+1)/2;" + "\n"
    line += "    " + "\n"
    line += "    root_arr[paraLimbCounter] = root;" + "\n"
    line += "    rootInverse_arr[paraLimbCounter] = rootInverse;" + "\n"
    line += "    twoInverse_arr[paraLimbCounter] = twoInverse;" + "\n"
    line += "  }" + "\n"
    line += "}" + "\n"

    return line